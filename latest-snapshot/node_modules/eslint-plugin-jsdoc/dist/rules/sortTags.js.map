{"version":3,"file":"sortTags.js","names":["_defaultTagOrder","_interopRequireDefault","require","_iterateJsdoc","obj","__esModule","default","_default","exports","iterateJsdoc","context","jsdoc","utils","linesBetween","tagSequence","defaultTagOrder","alphabetizeExtras","reportTagGroupSpacing","reportIntraTagGroupSpacing","options","tagList","flatMap","tags","otherPos","indexOf","endPos","length","ongoingCount","idx","tag","entries","originalIndex","source","originalLine","firstChangedTagLine","firstChangedTagIndex","sortedTags","JSON","parse","stringify","sort","tagNew","tagOld","checkOrSetFirstChanged","newPos","oldPos","preferredNewPos","preferredOldPos","undefined","lastTagsOfGroup","badLastTagsOfGroup","countTagEmptyLines","reduce","acc","tokens","description","name","type","end","tg","empty","Number","innerIdx","currentTag","lastTag","includes","some","tgs","push","ct","fixer","currIdx","newIdx","emptyLine","number","seedTokens","delimiter","start","existingEmptyLines","_jsdoc$source$newIdx","nextTokens","lineDiff","lines","Array","from","splice","srcIdx","src","reportJSDoc","tagIdx","foundFirstTag","nextIdx","ignore","lastTagOfGroup","_jsdoc$source$nextIdx","_jsdoc$source$nextIdx2","firstLine","getFirstLine","fix","itemsToMoveRange","keys","unchangedPriorTagDescriptions","slice","initialOffset","removeTag","changedTags","extraTagCount","changedTag","addTag","addLine","join","iterateAllJsdocs","meta","docs","url","fixable","schema","additionalProperties","properties","items","module"],"sources":["../../src/rules/sortTags.js"],"sourcesContent":["import defaultTagOrder from '../defaultTagOrder.js';\nimport iterateJsdoc from '../iterateJsdoc.js';\n\n// eslint-disable-next-line complexity -- Temporary\nexport default iterateJsdoc(({\n  context,\n  jsdoc,\n  utils,\n}) => {\n  const\n    /**\n     * @type {{\n     *   linesBetween: import('../iterateJsdoc.js').Integer,\n     *   tagSequence: {\n     *     tags: string[]\n     *   }[],\n     *   alphabetizeExtras: boolean,\n     *   reportTagGroupSpacing: boolean,\n     *   reportIntraTagGroupSpacing: boolean,\n     * }}\n     */ {\n      linesBetween = 1,\n      tagSequence = defaultTagOrder,\n      alphabetizeExtras = false,\n      reportTagGroupSpacing = true,\n      reportIntraTagGroupSpacing = true,\n    } = context.options[0] || {};\n\n  const tagList = tagSequence.flatMap((obj) => {\n    /* typeof obj === 'string' ? obj : */\n    return obj.tags;\n  });\n\n  const otherPos = tagList.indexOf('-other');\n  const endPos = otherPos > -1 ? otherPos : tagList.length;\n\n  let ongoingCount = 0;\n  for (const [\n    idx,\n    tag,\n  ] of\n    /**\n     * @type {(\n     *   import('@es-joy/jsdoccomment').JsdocTagWithInline & {\n     *     originalIndex: import('../iterateJsdoc.js').Integer,\n     *     originalLine: import('../iterateJsdoc.js').Integer,\n     *   }\n     * )[]}\n     */ (jsdoc.tags).entries()) {\n    tag.originalIndex = idx;\n    ongoingCount += tag.source.length;\n    tag.originalLine = ongoingCount;\n  }\n\n  /** @type {import('../iterateJsdoc.js').Integer|undefined} */\n  let firstChangedTagLine;\n  /** @type {import('../iterateJsdoc.js').Integer|undefined} */\n  let firstChangedTagIndex;\n\n  /**\n   * @type {(import('comment-parser').Spec & {\n   *   originalIndex: import('../iterateJsdoc.js').Integer,\n   *   originalLine: import('../iterateJsdoc.js').Integer,\n   * })[]}\n   */\n  const sortedTags = JSON.parse(JSON.stringify(jsdoc.tags));\n  sortedTags.sort(({\n    tag: tagNew,\n  }, {\n    originalIndex,\n    originalLine,\n    tag: tagOld,\n  }) => {\n    // Optimize: Just keep relative positions if the same tag name\n    if (tagNew === tagOld) {\n      return 0;\n    }\n\n    const checkOrSetFirstChanged = () => {\n      if (!firstChangedTagLine || originalLine < firstChangedTagLine) {\n        firstChangedTagLine = originalLine;\n        firstChangedTagIndex = originalIndex;\n      }\n    };\n\n    const newPos = tagList.indexOf(tagNew);\n    const oldPos = tagList.indexOf(tagOld);\n\n    const preferredNewPos = newPos === -1 ? endPos : newPos;\n    const preferredOldPos = oldPos === -1 ? endPos : oldPos;\n\n    if (preferredNewPos < preferredOldPos) {\n      checkOrSetFirstChanged();\n      return -1;\n    }\n\n    if (preferredNewPos > preferredOldPos) {\n      return 1;\n    }\n\n    // preferredNewPos === preferredOldPos\n    if (\n      !alphabetizeExtras ||\n\n      // Optimize: If tagNew (or tagOld which is the same) was found in the\n      //   priority array, it can maintain its relative positionâ€”without need\n      //   of alphabetizing (secondary sorting)\n      newPos >= 0\n    ) {\n      return 0;\n    }\n\n    if (tagNew < tagOld) {\n      checkOrSetFirstChanged();\n      return -1;\n    }\n\n    // tagNew > tagOld\n    return 1;\n  });\n\n  if (firstChangedTagLine === undefined) {\n    // Should be ordered by now\n\n    /**\n     * @type {import('comment-parser').Spec[]}\n     */\n    const lastTagsOfGroup = [];\n\n    /**\n     * @type {[\n     *   import('comment-parser').Spec,\n     *   import('../iterateJsdoc.js').Integer\n     * ][]}\n     */\n    const badLastTagsOfGroup = [];\n\n    /**\n     * @param {import('comment-parser').Spec} tag\n     */\n    const countTagEmptyLines = (tag) => {\n      return tag.source.reduce((acc, {\n        tokens: {\n          description,\n          name,\n          type,\n          end,\n          tag: tg,\n        },\n      }) => {\n        const empty = !tg && !type && !name && !description;\n        // Reset the count so long as there is content\n        return empty ? acc + Number(empty && !end) : 0;\n      }, 0);\n    };\n\n    let idx = 0;\n    for (const {\n      tags,\n    } of tagSequence) {\n      let innerIdx;\n      /** @type {import('comment-parser').Spec} */\n      let currentTag;\n      /** @type {import('comment-parser').Spec|undefined} */\n      let lastTag;\n      do {\n        currentTag = jsdoc.tags[idx];\n        if (!currentTag) {\n          idx++;\n          break;\n        }\n\n        innerIdx = tags.indexOf(currentTag.tag);\n\n        if (\n          innerIdx === -1 &&\n          // eslint-disable-next-line no-loop-func -- Safe\n          (!tags.includes('-other') || tagSequence.some(({\n            tags: tgs,\n          }) => {\n            return tgs.includes(currentTag.tag);\n          }))\n        ) {\n          idx++;\n          break;\n        }\n\n        lastTag = currentTag;\n\n        idx++;\n      } while (true);\n\n      idx--;\n\n      if (lastTag) {\n        lastTagsOfGroup.push(lastTag);\n        const ct = countTagEmptyLines(lastTag);\n        if (\n          ct !== linesBetween &&\n          // Use another rule for adding to end (should be of interest outside this rule)\n          jsdoc.tags[idx]\n        ) {\n          badLastTagsOfGroup.push([\n            lastTag, ct,\n          ]);\n        }\n      }\n    }\n\n    if (reportTagGroupSpacing && badLastTagsOfGroup.length) {\n      /**\n       * @param {import('comment-parser').Spec} tg\n       * @returns {() => void}\n       */\n      const fixer = (tg) => {\n        return () => {\n          // Due to https://github.com/syavorsky/comment-parser/issues/110 ,\n          //  we have to modify `jsdoc.source` rather than just modify tags\n          //  directly\n          for (const [\n            currIdx,\n            {\n              tokens,\n            },\n          ] of jsdoc.source.entries()) {\n            if (tokens.tag !== '@' + tg.tag) {\n              continue;\n            }\n\n            // Cannot be `tokens.end`, as dropped off last tag, so safe to\n            //  go on\n            let newIdx = currIdx;\n\n            const emptyLine = () => {\n              return {\n                number: 0,\n                source: '',\n                tokens: utils.seedTokens({\n                  delimiter: '*',\n                  start: jsdoc.source[newIdx - 1].tokens.start,\n                }),\n              };\n            };\n\n            let existingEmptyLines = 0;\n            while (true) {\n              const nextTokens = jsdoc.source[++newIdx]?.tokens;\n\n              /* istanbul ignore if -- Guard */\n              if (!nextTokens) {\n                return;\n              }\n\n              // Should be no `nextTokens.end` to worry about since ignored\n              //  if not followed by tag\n\n              if (nextTokens.tag) {\n                // Haven't made it to last tag instance yet, so keep looking\n                if (nextTokens.tag === tokens.tag) {\n                  existingEmptyLines = 0;\n                  continue;\n                }\n\n                const lineDiff = linesBetween - existingEmptyLines;\n                if (lineDiff > 0) {\n                  const lines = Array.from({\n                    length: lineDiff,\n                  }, () => {\n                    return emptyLine();\n                  });\n                  jsdoc.source.splice(newIdx, 0, ...lines);\n                } else {\n                  // lineDiff < 0\n                  jsdoc.source.splice(\n                    newIdx + lineDiff,\n                    -lineDiff,\n                  );\n                }\n\n                break;\n              }\n\n              const empty = !nextTokens.type && !nextTokens.name &&\n                !nextTokens.description;\n\n              if (empty) {\n                existingEmptyLines++;\n              } else {\n                // Has content again, so reset empty line count\n                existingEmptyLines = 0;\n              }\n            }\n\n            break;\n          }\n\n          for (const [\n            srcIdx,\n            src,\n          ] of jsdoc.source.entries()) {\n            src.number = srcIdx;\n          }\n        };\n      };\n\n      for (const [\n        tg,\n      ] of badLastTagsOfGroup) {\n        utils.reportJSDoc(\n          'Tag groups do not have the expected whitespace',\n          tg,\n          fixer(tg),\n        );\n      }\n\n      return;\n    }\n\n    if (!reportIntraTagGroupSpacing) {\n      return;\n    }\n\n    for (const [\n      tagIdx,\n      tag,\n    ] of jsdoc.tags.entries()) {\n      if (!jsdoc.tags[tagIdx + 1] || lastTagsOfGroup.includes(tag)) {\n        continue;\n      }\n\n      const ct = countTagEmptyLines(tag);\n      if (ct) {\n        // eslint-disable-next-line complexity -- Temporary\n        const fixer = () => {\n          let foundFirstTag = false;\n\n          /** @type {string|undefined} */\n          let currentTag;\n\n          for (const [\n            currIdx,\n            {\n              tokens: {\n                description,\n                name,\n                type,\n                end,\n                tag: tg,\n              },\n            },\n          ] of jsdoc.source.entries()) {\n            if (tg) {\n              foundFirstTag = true;\n              currentTag = tg;\n            }\n\n            if (!foundFirstTag) {\n              continue;\n            }\n\n            if (currentTag && !tg && !type && !name && !description && !end) {\n              let nextIdx = currIdx;\n\n              let ignore = true;\n              // Even if a tag of the same name as the last tags in a group,\n              //  could still be an earlier tag in that group\n\n              // eslint-disable-next-line no-loop-func -- Safe\n              if (lastTagsOfGroup.some((lastTagOfGroup) => {\n                return currentTag === '@' + lastTagOfGroup.tag;\n              })) {\n                while (true) {\n                  const nextTokens = jsdoc.source[++nextIdx]?.tokens;\n                  if (!nextTokens) {\n                    break;\n                  }\n\n                  if (!nextTokens.tag) {\n                    continue;\n                  }\n\n                  // Followed by the same tag name, so not actually last in group,\n                  //   and of interest\n                  if (nextTokens.tag === currentTag) {\n                    ignore = false;\n                  }\n                }\n              } else {\n                while (true) {\n                  const nextTokens = jsdoc.source[++nextIdx]?.tokens;\n                  if (!nextTokens || nextTokens.end) {\n                    break;\n                  }\n\n                  // Not the very last tag, so don't ignore\n                  if (nextTokens.tag) {\n                    ignore = false;\n                    break;\n                  }\n                }\n              }\n\n              if (!ignore) {\n                jsdoc.source.splice(currIdx, 1);\n                for (const [\n                  srcIdx,\n                  src,\n                ] of jsdoc.source.entries()) {\n                  src.number = srcIdx;\n                }\n              }\n            }\n          }\n        };\n\n        utils.reportJSDoc(\n          'Intra-group tags have unexpected whitespace',\n          tag,\n          fixer,\n        );\n      }\n    }\n\n    return;\n  }\n\n  const firstLine = utils.getFirstLine();\n\n  const fix = () => {\n    const itemsToMoveRange = [\n      ...Array.from({\n        length: jsdoc.tags.length -\n        /** @type {import('../iterateJsdoc.js').Integer} */ (\n          firstChangedTagIndex\n        ),\n      }).keys(),\n    ];\n\n    const unchangedPriorTagDescriptions = jsdoc.tags.slice(\n      0,\n      firstChangedTagIndex,\n    ).reduce((ct, {\n      source,\n    }) => {\n      return ct + source.length - 1;\n    }, 0);\n\n    // This offset includes not only the offset from where the first tag\n    //   must begin, and the additional offset of where the first changed\n    //   tag begins, but it must also account for prior descriptions\n    const initialOffset = /** @type {import('../iterateJsdoc.js').Integer} */ (\n      firstLine\n    ) + /** @type {import('../iterateJsdoc.js').Integer} */ (firstChangedTagIndex) +\n\n      // May be the first tag, so don't try finding a prior one if so\n      unchangedPriorTagDescriptions;\n\n    // Use `firstChangedTagLine` for line number to begin reporting/splicing\n    for (const idx of itemsToMoveRange) {\n      utils.removeTag(\n        idx +\n        /** @type {import('../iterateJsdoc.js').Integer} */ (\n          firstChangedTagIndex\n        ),\n      );\n    }\n\n    const changedTags = sortedTags.slice(firstChangedTagIndex);\n    let extraTagCount = 0;\n\n    for (const idx of itemsToMoveRange) {\n      const changedTag = changedTags[idx];\n\n      utils.addTag(\n        changedTag.tag,\n        extraTagCount + initialOffset + idx,\n        {\n          ...changedTag.source[0].tokens,\n\n          // `comment-parser` puts the `end` within the `tags` section, so\n          //   avoid adding another to jsdoc.source\n          end: '',\n        },\n      );\n\n      for (const {\n        tokens,\n      } of changedTag.source.slice(1)) {\n        if (!tokens.end) {\n          utils.addLine(\n            extraTagCount + initialOffset + idx + 1,\n            {\n              ...tokens,\n              end: '',\n            },\n          );\n          extraTagCount++;\n        }\n      }\n    }\n  };\n\n  utils.reportJSDoc(\n    `Tags are not in the prescribed order: ${\n      tagList.join(', ') || '(alphabetical)'\n    }`,\n    jsdoc.tags[/** @type {import('../iterateJsdoc.js').Integer} */ (\n      firstChangedTagIndex\n    )],\n    fix,\n    true,\n  );\n}, {\n  iterateAllJsdocs: true,\n  meta: {\n    docs: {\n      description: 'Sorts tags by a specified sequence according to tag name.',\n      url: 'https://github.com/gajus/eslint-plugin-jsdoc/blob/main/docs/rules/sort-tags.md#repos-sticky-header',\n    },\n    fixable: 'code',\n    schema: [\n      {\n        additionalProperties: false,\n        properties: {\n          alphabetizeExtras: {\n            type: 'boolean',\n          },\n          linesBetween: {\n            type: 'integer',\n          },\n          reportIntraTagGroupSpacing: {\n            type: 'boolean',\n          },\n          reportTagGroupSpacing: {\n            type: 'boolean',\n          },\n          tagSequence: {\n            items: {\n              properties: {\n                tags: {\n                  items: {\n                    type: 'string',\n                  },\n                  type: 'array',\n                },\n              },\n              type: 'object',\n            },\n            type: 'array',\n          },\n        },\n        type: 'object',\n      },\n    ],\n    type: 'suggestion',\n  },\n});\n"],"mappings":"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"}