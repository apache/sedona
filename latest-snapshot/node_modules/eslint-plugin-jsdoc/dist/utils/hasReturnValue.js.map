{"version":3,"file":"hasReturnValue.js","names":["isNewPromiseExpression","node","type","callee","name","isVoidPromise","_node$typeParameters","typeParameters","params","undefinedKeywords","Set","hasReturnValue","throwOnNullReturn","promFilter","_node$returnType","returnType","typeAnnotation","has","value","expression","body","some","bodyNode","consequent","alternate","block","handler","finalizer","cases","someCase","nde","argument","Error","exports","allBrancheshaveReturnValues","_node$returnType2","lastBodyNode","slice","test","error","message","every","consNode","hasNonEmptyResolverCall","resolverName","arguments","length","undefined","_node$params$","elements","element","right","left","expressions","subExpression","properties","property","decorators","decorator","computed","key","declarations","id","init","quasi","object","source","hasValueOrExecutorHasNonEmptyResolveValue","anyPromiseAsReturn","allBranches","hasReturnMethod","promiseFilter","hasReturn","Boolean","prom"],"sources":["../../src/utils/hasReturnValue.js"],"sourcesContent":["/**\n * @typedef {import('estree').Node|\n *   import('@typescript-eslint/types').TSESTree.Node} ESTreeOrTypeScriptNode\n */\n\n/**\n * Checks if a node is a promise but has no resolve value or an empty value.\n * An `undefined` resolve does not count.\n * @param {ESTreeOrTypeScriptNode|undefined|null} node\n * @returns {boolean|undefined|null}\n */\nconst isNewPromiseExpression = (node) => {\n  return node && node.type === 'NewExpression' && node.callee.type === 'Identifier' &&\n    node.callee.name === 'Promise';\n};\n\n/**\n * @param {ESTreeOrTypeScriptNode|null|undefined} node\n * @returns {boolean}\n */\nconst isVoidPromise = (node) => {\n  return /** @type {import('@typescript-eslint/types').TSESTree.TSTypeReference} */ (\n    node\n  )?.typeParameters?.params?.[0]?.type === 'TSVoidKeyword';\n};\n\nconst undefinedKeywords = new Set([\n  'TSVoidKeyword', 'TSUndefinedKeyword', 'TSNeverKeyword',\n]);\n\n/**\n * Checks if a node has a return statement. Void return does not count.\n * @param {ESTreeOrTypeScriptNode|undefined|null} node\n * @param {boolean} [throwOnNullReturn]\n * @param {PromiseFilter} [promFilter]\n * @returns {boolean|undefined}\n */\n// eslint-disable-next-line complexity\nconst hasReturnValue = (node, throwOnNullReturn, promFilter) => {\n  if (!node) {\n    return false;\n  }\n\n  switch (node.type) {\n  case 'TSDeclareFunction':\n  case 'TSFunctionType':\n  case 'TSMethodSignature': {\n    const type = node?.returnType?.typeAnnotation?.type;\n    return type && !undefinedKeywords.has(type);\n  }\n\n  case 'MethodDefinition':\n    return hasReturnValue(node.value, throwOnNullReturn, promFilter);\n  case 'FunctionExpression':\n  case 'FunctionDeclaration':\n  case 'ArrowFunctionExpression': {\n    return 'expression' in node && node.expression && (!isNewPromiseExpression(\n      node.body,\n    ) || !isVoidPromise(node.body)) ||\n      hasReturnValue(node.body, throwOnNullReturn, promFilter);\n  }\n\n  case 'BlockStatement': {\n    return node.body.some((bodyNode) => {\n      return bodyNode.type !== 'FunctionDeclaration' && hasReturnValue(bodyNode, throwOnNullReturn, promFilter);\n    });\n  }\n\n  case 'LabeledStatement':\n  case 'WhileStatement':\n  case 'DoWhileStatement':\n  case 'ForStatement':\n  case 'ForInStatement':\n  case 'ForOfStatement':\n  case 'WithStatement': {\n    return hasReturnValue(node.body, throwOnNullReturn, promFilter);\n  }\n\n  case 'IfStatement': {\n    return hasReturnValue(node.consequent, throwOnNullReturn, promFilter) ||\n      hasReturnValue(node.alternate, throwOnNullReturn, promFilter);\n  }\n\n  case 'TryStatement': {\n    return hasReturnValue(node.block, throwOnNullReturn, promFilter) ||\n      hasReturnValue(node.handler && node.handler.body, throwOnNullReturn, promFilter) ||\n      hasReturnValue(node.finalizer, throwOnNullReturn, promFilter);\n  }\n\n  case 'SwitchStatement': {\n    return node.cases.some(\n      (someCase) => {\n        return someCase.consequent.some((nde) => {\n          return hasReturnValue(nde, throwOnNullReturn, promFilter);\n        });\n      },\n    );\n  }\n\n  case 'ReturnStatement': {\n    // void return does not count.\n    if (node.argument === null) {\n      if (throwOnNullReturn) {\n        throw new Error('Null return');\n      }\n\n      return false;\n    }\n\n    if (promFilter && isNewPromiseExpression(node.argument)) {\n      // Let caller decide how to filter, but this is, at the least,\n      //   a return of sorts and truthy\n      return promFilter(node.argument);\n    }\n\n    return true;\n  }\n\n  default: {\n    return false;\n  }\n  }\n};\n\n/**\n * Checks if a node has a return statement. Void return does not count.\n * @param {ESTreeOrTypeScriptNode|null|undefined} node\n * @param {PromiseFilter} promFilter\n * @returns {undefined|boolean|ESTreeOrTypeScriptNode}\n */\n// eslint-disable-next-line complexity\nconst allBrancheshaveReturnValues = (node, promFilter) => {\n  if (!node) {\n    return false;\n  }\n\n  switch (node.type) {\n  case 'TSDeclareFunction':\n  case 'TSFunctionType':\n  case 'TSMethodSignature': {\n    const type = node?.returnType?.typeAnnotation?.type;\n    return type && !undefinedKeywords.has(type);\n  }\n\n  // case 'MethodDefinition':\n  //   return allBrancheshaveReturnValues(node.value, promFilter);\n  case 'FunctionExpression':\n  case 'FunctionDeclaration':\n  case 'ArrowFunctionExpression': {\n    return 'expression' in node && node.expression && (!isNewPromiseExpression(node.body) || !isVoidPromise(node.body)) ||\n      allBrancheshaveReturnValues(node.body, promFilter) ||\n      /** @type {import('@typescript-eslint/types').TSESTree.BlockStatement} */\n      (node.body).body.some((nde) => {\n        return nde.type === 'ReturnStatement';\n      });\n  }\n\n  case 'BlockStatement': {\n    const lastBodyNode = node.body.slice(-1)[0];\n    return allBrancheshaveReturnValues(lastBodyNode, promFilter);\n  }\n\n  case 'WhileStatement':\n  case 'DoWhileStatement':\n    if (\n      /**\n       * @type {import('@typescript-eslint/types').TSESTree.Literal}\n       */\n      (node.test).value === true\n    ) {\n      // If this is an infinite loop, we assume only one branch\n      //   is needed to provide a return\n      return hasReturnValue(node.body, false, promFilter);\n    }\n\n    // Fallthrough\n  case 'LabeledStatement':\n  case 'ForStatement':\n  case 'ForInStatement':\n  case 'ForOfStatement':\n  case 'WithStatement': {\n    return allBrancheshaveReturnValues(node.body, promFilter);\n  }\n\n  case 'IfStatement': {\n    return allBrancheshaveReturnValues(node.consequent, promFilter) &&\n      allBrancheshaveReturnValues(node.alternate, promFilter);\n  }\n\n  case 'TryStatement': {\n    // If `finally` returns, all return\n    return node.finalizer && allBrancheshaveReturnValues(node.finalizer, promFilter) ||\n      // Return in `try`/`catch` may still occur despite `finally`\n      allBrancheshaveReturnValues(node.block, promFilter) &&\n        (!node.handler ||\n          allBrancheshaveReturnValues(node.handler && node.handler.body, promFilter)) &&\n          (!node.finalizer || (() => {\n            try {\n              hasReturnValue(node.finalizer, true, promFilter);\n            } catch (error) {\n              // istanbul ignore else\n              if (/** @type {Error} */ (error).message === 'Null return') {\n                return false;\n              }\n\n              // istanbul ignore next\n              throw error;\n            }\n\n            // As long as not an explicit empty return, then return true\n            return true;\n          })());\n  }\n\n  case 'SwitchStatement': {\n    return /** @type {import('@typescript-eslint/types').TSESTree.SwitchStatement} */ (node).cases.every(\n      (someCase) => {\n        return !someCase.consequent.some((consNode) => {\n          return consNode.type === 'BreakStatement' ||\n            consNode.type === 'ReturnStatement' && consNode.argument === null;\n        });\n      },\n    );\n  }\n\n  case 'ThrowStatement': {\n    return true;\n  }\n\n  case 'ReturnStatement': {\n    // void return does not count.\n    if (node.argument === null) {\n      return false;\n    }\n\n    if (promFilter && isNewPromiseExpression(node.argument)) {\n      // Let caller decide how to filter, but this is, at the least,\n      //   a return of sorts and truthy\n      return promFilter(node.argument);\n    }\n\n    return true;\n  }\n\n  default: {\n    return false;\n  }\n  }\n};\n\n/**\n * @callback PromiseFilter\n * @param {ESTreeOrTypeScriptNode|undefined} node\n * @returns {boolean}\n */\n\n/**\n * Avoids further checking child nodes if a nested function shadows the\n * resolver, but otherwise, if name is used (by call or passed in as an\n * argument to another function), will be considered as non-empty.\n *\n * This could check for redeclaration of the resolver, but as such is\n * unlikely, we avoid the performance cost of checking everywhere for\n * (re)declarations or assignments.\n * @param {import('@typescript-eslint/types').TSESTree.Node|null|undefined} node\n * @param {string} resolverName\n * @returns {boolean}\n */\n// eslint-disable-next-line complexity\nconst hasNonEmptyResolverCall = (node, resolverName) => {\n  if (!node) {\n    return false;\n  }\n\n  // Arrow function without block\n  switch (node.type) {\n  // @ts-expect-error Babel?\n  // istanbul ignore next -- In Babel?\n  case 'OptionalCallExpression':\n  case 'CallExpression':\n    return /** @type {import('@typescript-eslint/types').TSESTree.Identifier} */ (\n      node.callee\n    ).name === resolverName && (\n\n      // Implicit or explicit undefined\n      node.arguments.length > 1 || node.arguments[0] !== undefined\n    ) ||\n      node.arguments.some((nde) => {\n        // Being passed in to another function (which might invoke it)\n        return nde.type === 'Identifier' && nde.name === resolverName ||\n\n          // Handle nested items\n          hasNonEmptyResolverCall(nde, resolverName);\n      });\n  case 'ChainExpression':\n  case 'Decorator':\n  case 'ExpressionStatement':\n    return hasNonEmptyResolverCall(node.expression, resolverName);\n  case 'ClassBody':\n  case 'BlockStatement':\n    return node.body.some((bodyNode) => {\n      return hasNonEmptyResolverCall(bodyNode, resolverName);\n    });\n  case 'FunctionExpression':\n  case 'FunctionDeclaration':\n  case 'ArrowFunctionExpression': {\n    // Shadowing\n    if (/** @type {import('@typescript-eslint/types').TSESTree.Identifier} */ (\n      node.params[0]\n    )?.name === resolverName) {\n      return false;\n    }\n\n    return hasNonEmptyResolverCall(node.body, resolverName);\n  }\n\n  case 'LabeledStatement':\n  case 'WhileStatement':\n  case 'DoWhileStatement':\n  case 'ForStatement':\n  case 'ForInStatement':\n  case 'ForOfStatement':\n  case 'WithStatement': {\n    return hasNonEmptyResolverCall(node.body, resolverName);\n  }\n\n  case 'ConditionalExpression':\n  case 'IfStatement': {\n    return hasNonEmptyResolverCall(node.test, resolverName) ||\n      hasNonEmptyResolverCall(node.consequent, resolverName) ||\n      hasNonEmptyResolverCall(node.alternate, resolverName);\n  }\n\n  case 'TryStatement': {\n    return hasNonEmptyResolverCall(node.block, resolverName) ||\n      hasNonEmptyResolverCall(node.handler && node.handler.body, resolverName) ||\n      hasNonEmptyResolverCall(node.finalizer, resolverName);\n  }\n\n  case 'SwitchStatement': {\n    return node.cases.some(\n      (someCase) => {\n        return someCase.consequent.some((nde) => {\n          return hasNonEmptyResolverCall(nde, resolverName);\n        });\n      },\n    );\n  }\n\n  case 'ArrayPattern':\n  case 'ArrayExpression':\n    return node.elements.some((element) => {\n      return hasNonEmptyResolverCall(element, resolverName);\n    });\n\n  case 'AssignmentPattern':\n    return hasNonEmptyResolverCall(node.right, resolverName);\n\n  case 'AssignmentExpression':\n  case 'BinaryExpression':\n  case 'LogicalExpression': {\n    return hasNonEmptyResolverCall(node.left, resolverName) ||\n      hasNonEmptyResolverCall(node.right, resolverName);\n  }\n\n  // Comma\n  case 'SequenceExpression':\n  case 'TemplateLiteral':\n    return node.expressions.some((subExpression) => {\n      return hasNonEmptyResolverCall(subExpression, resolverName);\n    });\n\n  case 'ObjectPattern':\n  case 'ObjectExpression':\n    return node.properties.some((property) => {\n      return hasNonEmptyResolverCall(property, resolverName);\n    });\n  // @ts-expect-error Babel?\n  // istanbul ignore next -- In Babel?\n  case 'ClassMethod':\n  case 'MethodDefinition':\n    return node.decorators && node.decorators.some((decorator) => {\n      return hasNonEmptyResolverCall(decorator, resolverName);\n    }) ||\n      node.computed && hasNonEmptyResolverCall(node.key, resolverName) ||\n      hasNonEmptyResolverCall(node.value, resolverName);\n\n  // @ts-expect-error Babel?\n  // istanbul ignore next -- In Babel?\n  case 'ObjectProperty':\n  /* eslint-disable no-fallthrough */\n  // istanbul ignore next -- In Babel?\n  case 'PropertyDefinition':\n  // @ts-expect-error Babel?\n  // istanbul ignore next -- In Babel?\n  case 'ClassProperty':\n  case 'Property':\n  /* eslint-enable no-fallthrough */\n    return node.computed && hasNonEmptyResolverCall(node.key, resolverName) ||\n      hasNonEmptyResolverCall(node.value, resolverName);\n  // @ts-expect-error Babel?\n  // istanbul ignore next -- In Babel?\n  case 'ObjectMethod':\n    // @ts-expect-error\n    // istanbul ignore next -- In Babel?\n    return node.computed && hasNonEmptyResolverCall(node.key, resolverName) ||\n      // @ts-expect-error\n      node.arguments.some((nde) => {\n        return hasNonEmptyResolverCall(nde, resolverName);\n      });\n\n  case 'ClassExpression':\n  case 'ClassDeclaration':\n    return hasNonEmptyResolverCall(node.body, resolverName);\n\n  case 'AwaitExpression':\n  case 'SpreadElement':\n  case 'UnaryExpression':\n  case 'YieldExpression':\n    return hasNonEmptyResolverCall(node.argument, resolverName);\n\n  case 'VariableDeclaration': {\n    return node.declarations.some((nde) => {\n      return hasNonEmptyResolverCall(nde, resolverName);\n    });\n  }\n\n  case 'VariableDeclarator': {\n    return hasNonEmptyResolverCall(node.id, resolverName) ||\n      hasNonEmptyResolverCall(node.init, resolverName);\n  }\n\n  case 'TaggedTemplateExpression':\n    return hasNonEmptyResolverCall(node.quasi, resolverName);\n\n  // @ts-expect-error Babel?\n  // ?.\n  // istanbul ignore next -- In Babel?\n  case 'OptionalMemberExpression':\n  case 'MemberExpression':\n    return hasNonEmptyResolverCall(node.object, resolverName) ||\n      hasNonEmptyResolverCall(node.property, resolverName);\n\n  // @ts-expect-error Babel?\n  // istanbul ignore next -- In Babel?\n  case 'Import':\n  case 'ImportExpression':\n    return hasNonEmptyResolverCall(node.source, resolverName);\n\n  case 'ReturnStatement': {\n    if (node.argument === null) {\n      return false;\n    }\n\n    return hasNonEmptyResolverCall(node.argument, resolverName);\n  }\n\n  /*\n  // Shouldn't need to parse literals/literal components, etc.\n\n  case 'Identifier':\n  case 'TemplateElement':\n  case 'Super':\n  // Exports not relevant in this context\n  */\n  default:\n    return false;\n  }\n};\n\n/**\n * Checks if a Promise executor has no resolve value or an empty value.\n * An `undefined` resolve does not count.\n * @param {ESTreeOrTypeScriptNode} node\n * @param {boolean} anyPromiseAsReturn\n * @param {boolean} [allBranches]\n * @returns {boolean}\n */\nconst hasValueOrExecutorHasNonEmptyResolveValue = (node, anyPromiseAsReturn, allBranches) => {\n  const hasReturnMethod = allBranches ?\n    /**\n     * @param {ESTreeOrTypeScriptNode} nde\n     * @param {PromiseFilter} promiseFilter\n     * @returns {boolean}\n     */\n    (nde, promiseFilter) => {\n      let hasReturn;\n      try {\n        hasReturn = hasReturnValue(nde, true, promiseFilter);\n      } catch (error) {\n        // istanbul ignore else\n        if (/** @type {Error} */ (error).message === 'Null return') {\n          return false;\n        }\n\n        // istanbul ignore next\n        throw error;\n      }\n\n      // `hasReturn` check needed since `throw` treated as valid return by\n      //   `allBrancheshaveReturnValues`\n      return Boolean(hasReturn && allBrancheshaveReturnValues(nde, promiseFilter));\n    } :\n    /**\n     * @param {ESTreeOrTypeScriptNode} nde\n     * @param {PromiseFilter} promiseFilter\n     * @returns {boolean}\n     */\n    (nde, promiseFilter) => {\n      return Boolean(hasReturnValue(nde, false, promiseFilter));\n    };\n\n  return hasReturnMethod(node, (prom) => {\n    if (anyPromiseAsReturn) {\n      return true;\n    }\n\n    if (isVoidPromise(prom)) {\n      return false;\n    }\n\n    const {\n      params,\n      body,\n    } =\n    /**\n     * @type {import('@typescript-eslint/types').TSESTree.FunctionExpression|\n     * import('@typescript-eslint/types').TSESTree.ArrowFunctionExpression}\n     */ (\n      /** @type {import('@typescript-eslint/types').TSESTree.NewExpression} */ (\n          prom\n        ).arguments[0]\n      ) || {};\n\n    if (!params?.length) {\n      return false;\n    }\n\n    const {\n      name: resolverName,\n    } = /** @type {import('@typescript-eslint/types').TSESTree.Identifier} */ (\n      params[0]\n    );\n\n    return hasNonEmptyResolverCall(body, resolverName);\n  });\n};\n\nexport {\n  hasReturnValue,\n  hasValueOrExecutorHasNonEmptyResolveValue,\n};\n"],"mappings":"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"}