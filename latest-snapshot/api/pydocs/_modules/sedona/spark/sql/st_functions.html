

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sedona.spark.sql.st_functions &mdash; Apache Sedona Python Documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/custom.css?v=08a75d8b" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=908dc885"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
     
    <!-- Google Fonts for Apache Sedona styling -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Additional meta tags for better rendering -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1565c0">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #ff5722" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            Apache Sedona Python
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules.html">sedona</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.html">sedona package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.html#subpackages">Subpackages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.core.html">sedona.core package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.flink.html">sedona.flink package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.geoarrow.html">sedona.geoarrow package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.maps.html">sedona.maps package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.raster.html">sedona.raster package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.raster_utils.html">sedona.raster_utils package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.register.html">sedona.register package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.html">sedona.spark package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.sql.html">sedona.sql package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.stac.html">sedona.stac package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.stats.html">sedona.stats package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.utils.html">sedona.utils package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.html#module-sedona.exceptions">sedona.exceptions module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.html#sedona.exceptions.InvalidParametersException"><code class="docutils literal notranslate"><span class="pre">InvalidParametersException</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.html#module-sedona.version">sedona.version module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.html#module-sedona">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../sedona.flink.html">sedona.flink package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.flink.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.flink.html#module-sedona.flink.context">sedona.flink.context module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.flink.html#sedona.flink.context.SedonaContext"><code class="docutils literal notranslate"><span class="pre">SedonaContext</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.flink.html#sedona.flink.context.SedonaContext.create"><code class="docutils literal notranslate"><span class="pre">SedonaContext.create()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.flink.html#module-sedona.flink">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../sedona.spark.html">sedona.spark package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.spark.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.core.html">sedona.spark.core package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.core.html#subpackages">Subpackages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.core.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.core.html#module-sedona.spark.core.utils">sedona.spark.core.utils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.core.html#module-sedona.spark.core">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.geoarrow.html">sedona.spark.geoarrow package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geoarrow.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geoarrow.html#module-sedona.spark.geoarrow.geoarrow">sedona.spark.geoarrow.geoarrow module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geoarrow.html#module-sedona.spark.geoarrow">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.geopandas.html">sedona.spark.geopandas package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html">sedona.spark.geopandas core</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.io.html">sedona.spark.geopandas.io</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.tools.html">sedona.spark.geopandas.tools</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.maps.html">sedona.spark.maps package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.maps.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.maps.html#module-sedona.spark.maps.SedonaKepler">sedona.spark.maps.SedonaKepler module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.maps.html#module-sedona.spark.maps.SedonaMapUtils">sedona.spark.maps.SedonaMapUtils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.maps.html#module-sedona.spark.maps.SedonaPyDeck">sedona.spark.maps.SedonaPyDeck module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.maps.html#module-sedona.spark.maps">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.raster.html">sedona.spark.raster package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.raster.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.raster.html#module-sedona.spark.raster.awt_raster">sedona.spark.raster.awt_raster module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.raster.html#module-sedona.spark.raster.data_buffer">sedona.spark.raster.data_buffer module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.raster.html#module-sedona.spark.raster.meta">sedona.spark.raster.meta module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.raster.html#module-sedona.spark.raster.raster_serde">sedona.spark.raster.raster_serde module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.raster.html#module-sedona.spark.raster.sample_model">sedona.spark.raster.sample_model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.raster.html#module-sedona.spark.raster.sedona_raster">sedona.spark.raster.sedona_raster module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.raster.html#module-sedona.spark.raster">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.raster_utils.html">sedona.spark.raster_utils package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.raster_utils.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.raster_utils.html#module-sedona.spark.raster_utils.SedonaUtils">sedona.spark.raster_utils.SedonaUtils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.raster_utils.html#module-sedona.spark.raster_utils">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.register.html">sedona.spark.register package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.register.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.register.html#module-sedona.spark.register.geo_registrator">sedona.spark.register.geo_registrator module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.register.html#module-sedona.spark.register.java_libs">sedona.spark.register.java_libs module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.register.html#module-sedona.spark.register">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.sql.html">sedona.spark.sql package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.sql.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.sql.html#sedona-spark-sql-connect-module">sedona.spark.sql.connect module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.sql.html#module-sedona.spark.sql.dataframe_api">sedona.spark.sql.dataframe_api module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.sql.html#module-sedona.spark.sql.exceptions">sedona.spark.sql.exceptions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.sql.html#module-sedona.spark.sql.functions">sedona.spark.sql.functions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.sql.html#module-sedona.spark.sql.st_aggregates">sedona.spark.sql.st_aggregates module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.sql.html#module-sedona.spark.sql.st_constructors">sedona.spark.sql.st_constructors module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.sql.html#module-sedona.spark.sql.st_functions">sedona.spark.sql.st_functions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.sql.html#module-sedona.spark.sql.st_predicates">sedona.spark.sql.st_predicates module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.sql.html#module-sedona.spark.sql.types">sedona.spark.sql.types module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.sql.html#module-sedona.spark.sql">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.stac.html">sedona.spark.stac package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.stac.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.stac.html#module-sedona.spark.stac.client">sedona.spark.stac.client module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.stac.html#module-sedona.spark.stac.collection_client">sedona.spark.stac.collection_client module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.stac.html#module-sedona.spark.stac">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.stats.html">sedona.spark.stats package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.stats.html#subpackages">Subpackages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.stats.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.stats.html#module-sedona.spark.stats.weighting">sedona.spark.stats.weighting module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.stats.html#module-sedona.spark.stats">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.utils.html">sedona.spark.utils package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.abstract_parser">sedona.spark.utils.abstract_parser module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.adapter">sedona.spark.utils.adapter module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.binary_parser">sedona.spark.utils.binary_parser module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.decorators">sedona.spark.utils.decorators module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.geometry_adapter">sedona.spark.utils.geometry_adapter module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.geometry_serde">sedona.spark.utils.geometry_serde module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.geometry_serde_general">sedona.spark.utils.geometry_serde_general module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.geomserde_speedup">sedona.spark.utils.geomserde_speedup module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.jvm">sedona.spark.utils.jvm module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.meta">sedona.spark.utils.meta module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.prep">sedona.spark.utils.prep module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.serde">sedona.spark.utils.serde module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.spatial_rdd_parser">sedona.spark.utils.spatial_rdd_parser module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.structured_adapter">sedona.spark.utils.structured_adapter module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.types">sedona.spark.utils.types module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.spark.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.spark.html#module-sedona.spark.SedonaContext">sedona.spark.SedonaContext module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.html#sedona.spark.SedonaContext.SedonaContext"><code class="docutils literal notranslate"><span class="pre">SedonaContext</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.html#sedona.spark.SedonaContext.SedonaContext.__init__"><code class="docutils literal notranslate"><span class="pre">SedonaContext.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.html#sedona.spark.SedonaContext.SedonaContext.builder"><code class="docutils literal notranslate"><span class="pre">SedonaContext.builder()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.html#sedona.spark.SedonaContext.SedonaContext.create"><code class="docutils literal notranslate"><span class="pre">SedonaContext.create()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.spark.html#module-sedona.spark">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../sedona.spark.geopandas.html">sedona.spark.geopandas package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html">sedona.spark.geopandas core</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries"><code class="docutils literal notranslate"><span class="pre">GeoSeries</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.__init__"><code class="docutils literal notranslate"><span class="pre">GeoSeries.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.area"><code class="docutils literal notranslate"><span class="pre">GeoSeries.area</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.boundary"><code class="docutils literal notranslate"><span class="pre">GeoSeries.boundary</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.bounds"><code class="docutils literal notranslate"><span class="pre">GeoSeries.bounds</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.buffer"><code class="docutils literal notranslate"><span class="pre">GeoSeries.buffer()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.centroid"><code class="docutils literal notranslate"><span class="pre">GeoSeries.centroid</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.clip"><code class="docutils literal notranslate"><span class="pre">GeoSeries.clip()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.concave_hull"><code class="docutils literal notranslate"><span class="pre">GeoSeries.concave_hull()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.contains"><code class="docutils literal notranslate"><span class="pre">GeoSeries.contains()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.contains_properly"><code class="docutils literal notranslate"><span class="pre">GeoSeries.contains_properly()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.convex_hull"><code class="docutils literal notranslate"><span class="pre">GeoSeries.convex_hull</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.copy"><code class="docutils literal notranslate"><span class="pre">GeoSeries.copy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.count_coordinates"><code class="docutils literal notranslate"><span class="pre">GeoSeries.count_coordinates()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.count_geometries"><code class="docutils literal notranslate"><span class="pre">GeoSeries.count_geometries()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.count_interior_rings"><code class="docutils literal notranslate"><span class="pre">GeoSeries.count_interior_rings()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.covered_by"><code class="docutils literal notranslate"><span class="pre">GeoSeries.covered_by()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.covers"><code class="docutils literal notranslate"><span class="pre">GeoSeries.covers()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.crosses"><code class="docutils literal notranslate"><span class="pre">GeoSeries.crosses()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.crs"><code class="docutils literal notranslate"><span class="pre">GeoSeries.crs</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.delaunay_triangles"><code class="docutils literal notranslate"><span class="pre">GeoSeries.delaunay_triangles()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.difference"><code class="docutils literal notranslate"><span class="pre">GeoSeries.difference()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.disjoint"><code class="docutils literal notranslate"><span class="pre">GeoSeries.disjoint()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.distance"><code class="docutils literal notranslate"><span class="pre">GeoSeries.distance()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.dwithin"><code class="docutils literal notranslate"><span class="pre">GeoSeries.dwithin()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.envelope"><code class="docutils literal notranslate"><span class="pre">GeoSeries.envelope</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.estimate_utm_crs"><code class="docutils literal notranslate"><span class="pre">GeoSeries.estimate_utm_crs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.explode"><code class="docutils literal notranslate"><span class="pre">GeoSeries.explode()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.exterior"><code class="docutils literal notranslate"><span class="pre">GeoSeries.exterior</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.extract_unique_points"><code class="docutils literal notranslate"><span class="pre">GeoSeries.extract_unique_points()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.fillna"><code class="docutils literal notranslate"><span class="pre">GeoSeries.fillna()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.force_2d"><code class="docutils literal notranslate"><span class="pre">GeoSeries.force_2d()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.force_3d"><code class="docutils literal notranslate"><span class="pre">GeoSeries.force_3d()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.from_arrow"><code class="docutils literal notranslate"><span class="pre">GeoSeries.from_arrow()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.from_file"><code class="docutils literal notranslate"><span class="pre">GeoSeries.from_file()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.from_shapely"><code class="docutils literal notranslate"><span class="pre">GeoSeries.from_shapely()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.from_wkb"><code class="docutils literal notranslate"><span class="pre">GeoSeries.from_wkb()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.from_wkt"><code class="docutils literal notranslate"><span class="pre">GeoSeries.from_wkt()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.from_xy"><code class="docutils literal notranslate"><span class="pre">GeoSeries.from_xy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.geom_type"><code class="docutils literal notranslate"><span class="pre">GeoSeries.geom_type</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.geometry"><code class="docutils literal notranslate"><span class="pre">GeoSeries.geometry</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.get_geometry"><code class="docutils literal notranslate"><span class="pre">GeoSeries.get_geometry()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.get_precision"><code class="docutils literal notranslate"><span class="pre">GeoSeries.get_precision()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.has_sindex"><code class="docutils literal notranslate"><span class="pre">GeoSeries.has_sindex</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.has_z"><code class="docutils literal notranslate"><span class="pre">GeoSeries.has_z</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.interiors"><code class="docutils literal notranslate"><span class="pre">GeoSeries.interiors</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.intersection"><code class="docutils literal notranslate"><span class="pre">GeoSeries.intersection()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.intersection_all"><code class="docutils literal notranslate"><span class="pre">GeoSeries.intersection_all()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.intersects"><code class="docutils literal notranslate"><span class="pre">GeoSeries.intersects()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.is_ccw"><code class="docutils literal notranslate"><span class="pre">GeoSeries.is_ccw</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.is_closed"><code class="docutils literal notranslate"><span class="pre">GeoSeries.is_closed</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.is_empty"><code class="docutils literal notranslate"><span class="pre">GeoSeries.is_empty</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.is_ring"><code class="docutils literal notranslate"><span class="pre">GeoSeries.is_ring</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.is_simple"><code class="docutils literal notranslate"><span class="pre">GeoSeries.is_simple</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.is_valid"><code class="docutils literal notranslate"><span class="pre">GeoSeries.is_valid</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.is_valid_reason"><code class="docutils literal notranslate"><span class="pre">GeoSeries.is_valid_reason()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.isna"><code class="docutils literal notranslate"><span class="pre">GeoSeries.isna()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.isnull"><code class="docutils literal notranslate"><span class="pre">GeoSeries.isnull()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.length"><code class="docutils literal notranslate"><span class="pre">GeoSeries.length</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.line_merge"><code class="docutils literal notranslate"><span class="pre">GeoSeries.line_merge()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.m"><code class="docutils literal notranslate"><span class="pre">GeoSeries.m</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.make_valid"><code class="docutils literal notranslate"><span class="pre">GeoSeries.make_valid()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.minimum_bounding_circle"><code class="docutils literal notranslate"><span class="pre">GeoSeries.minimum_bounding_circle()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.minimum_bounding_radius"><code class="docutils literal notranslate"><span class="pre">GeoSeries.minimum_bounding_radius()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.minimum_clearance"><code class="docutils literal notranslate"><span class="pre">GeoSeries.minimum_clearance()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.minimum_rotated_rectangle"><code class="docutils literal notranslate"><span class="pre">GeoSeries.minimum_rotated_rectangle()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.normalize"><code class="docutils literal notranslate"><span class="pre">GeoSeries.normalize()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.notna"><code class="docutils literal notranslate"><span class="pre">GeoSeries.notna()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.notnull"><code class="docutils literal notranslate"><span class="pre">GeoSeries.notnull()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.offset_curve"><code class="docutils literal notranslate"><span class="pre">GeoSeries.offset_curve()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.overlaps"><code class="docutils literal notranslate"><span class="pre">GeoSeries.overlaps()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.plot"><code class="docutils literal notranslate"><span class="pre">GeoSeries.plot()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.remove_repeated_points"><code class="docutils literal notranslate"><span class="pre">GeoSeries.remove_repeated_points()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.representative_point"><code class="docutils literal notranslate"><span class="pre">GeoSeries.representative_point()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.reverse"><code class="docutils literal notranslate"><span class="pre">GeoSeries.reverse()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.segmentize"><code class="docutils literal notranslate"><span class="pre">GeoSeries.segmentize()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.set_crs"><code class="docutils literal notranslate"><span class="pre">GeoSeries.set_crs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.set_precision"><code class="docutils literal notranslate"><span class="pre">GeoSeries.set_precision()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.simplify"><code class="docutils literal notranslate"><span class="pre">GeoSeries.simplify()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.sindex"><code class="docutils literal notranslate"><span class="pre">GeoSeries.sindex</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.snap"><code class="docutils literal notranslate"><span class="pre">GeoSeries.snap()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.to_arrow"><code class="docutils literal notranslate"><span class="pre">GeoSeries.to_arrow()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.to_crs"><code class="docutils literal notranslate"><span class="pre">GeoSeries.to_crs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.to_file"><code class="docutils literal notranslate"><span class="pre">GeoSeries.to_file()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.to_geoframe"><code class="docutils literal notranslate"><span class="pre">GeoSeries.to_geoframe()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.to_geopandas"><code class="docutils literal notranslate"><span class="pre">GeoSeries.to_geopandas()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.to_json"><code class="docutils literal notranslate"><span class="pre">GeoSeries.to_json()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.to_parquet"><code class="docutils literal notranslate"><span class="pre">GeoSeries.to_parquet()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.to_spark_pandas"><code class="docutils literal notranslate"><span class="pre">GeoSeries.to_spark_pandas()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.to_wkb"><code class="docutils literal notranslate"><span class="pre">GeoSeries.to_wkb()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.to_wkt"><code class="docutils literal notranslate"><span class="pre">GeoSeries.to_wkt()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.total_bounds"><code class="docutils literal notranslate"><span class="pre">GeoSeries.total_bounds</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.touches"><code class="docutils literal notranslate"><span class="pre">GeoSeries.touches()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.transform"><code class="docutils literal notranslate"><span class="pre">GeoSeries.transform()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.type"><code class="docutils literal notranslate"><span class="pre">GeoSeries.type</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.unary_union"><code class="docutils literal notranslate"><span class="pre">GeoSeries.unary_union</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.union_all"><code class="docutils literal notranslate"><span class="pre">GeoSeries.union_all()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.voronoi_polygons"><code class="docutils literal notranslate"><span class="pre">GeoSeries.voronoi_polygons()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.within"><code class="docutils literal notranslate"><span class="pre">GeoSeries.within()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.x"><code class="docutils literal notranslate"><span class="pre">GeoSeries.x</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.y"><code class="docutils literal notranslate"><span class="pre">GeoSeries.y</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoSeries.z"><code class="docutils literal notranslate"><span class="pre">GeoSeries.z</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.__init__"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.active_geometry_name"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.active_geometry_name</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.copy"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.copy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.crs"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.crs</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.from_arrow"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.from_arrow()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.from_dict"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.from_dict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.from_features"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.from_features()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.from_file"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.from_file()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.from_postgis"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.from_postgis()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.geometry"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.geometry</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.iterfeatures"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.iterfeatures()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.plot"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.plot()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.rename_geometry"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.rename_geometry()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.set_crs"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.set_crs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.set_geometry"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.set_geometry()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.sjoin"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.sjoin()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.to_arrow"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.to_arrow()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.to_crs"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.to_crs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.to_feather"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.to_feather()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.to_file"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.to_file()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.to_geo_dict"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.to_geo_dict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.to_geopandas"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.to_geopandas()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.to_json"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.to_json()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.to_parquet"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.to_parquet()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.to_spark_pandas"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.to_spark_pandas()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.to_wkb"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.to_wkb()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.to_wkt"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.to_wkt()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.GeoDataFrame.type"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.type</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.sindex.SpatialIndex"><code class="docutils literal notranslate"><span class="pre">SpatialIndex</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.sindex.SpatialIndex.__init__"><code class="docutils literal notranslate"><span class="pre">SpatialIndex.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.sindex.SpatialIndex.intersection"><code class="docutils literal notranslate"><span class="pre">SpatialIndex.intersection()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.sindex.SpatialIndex.is_empty"><code class="docutils literal notranslate"><span class="pre">SpatialIndex.is_empty</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.sindex.SpatialIndex.nearest"><code class="docutils literal notranslate"><span class="pre">SpatialIndex.nearest()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.sindex.SpatialIndex.query"><code class="docutils literal notranslate"><span class="pre">SpatialIndex.query()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.api.html#sedona.spark.geopandas.sindex.SpatialIndex.size"><code class="docutils literal notranslate"><span class="pre">SpatialIndex.size</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.spark.geopandas.io.html">sedona.spark.geopandas.io</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.geopandas.io.html#sedona.spark.geopandas.io.read_file"><code class="docutils literal notranslate"><span class="pre">read_file()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.geopandas.io.html#sedona.spark.geopandas.io.read_parquet"><code class="docutils literal notranslate"><span class="pre">read_parquet()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.spark.geopandas.tools.html">sedona.spark.geopandas.tools</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.geopandas.tools.html#sedona.spark.geopandas.tools.sjoin.sjoin"><code class="docutils literal notranslate"><span class="pre">sjoin()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../sedona.stac.html">sedona.stac package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.stac.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.stac.html#module-sedona.stac.client">sedona.stac.client module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.stac.html#module-sedona.stac.collection_client">sedona.stac.collection_client module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.stac.html#module-sedona.stac">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../sedona.stats.html">sedona.stats package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.stats.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.stats.clustering.html">sedona.stats.clustering package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.stats.clustering.html#subpackages">Subpackages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.stats.clustering.html#module-sedona.stats.clustering">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.stats.hotspot_detection.html">sedona.stats.hotspot_detection package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.stats.hotspot_detection.html#subpackages">Subpackages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.stats.hotspot_detection.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.stats.hotspot_detection.html#module-sedona.stats.hotspot_detection.getis_ord">sedona.stats.hotspot_detection.getis_ord module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.stats.hotspot_detection.html#module-sedona.stats.hotspot_detection">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.stats.outlier_detection.html">sedona.stats.outlier_detection package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.stats.outlier_detection.html#subpackages">Subpackages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.stats.outlier_detection.html#module-sedona.stats.outlier_detection">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.stats.weighting.html">sedona.stats.weighting package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.stats.weighting.html#module-sedona.stats.weighting">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.stats.html#module-sedona.stats">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../sedona.utils.html">sedona.utils package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.utils.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.utils.structured_adapter.html">sedona.utils.structured_adapter package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.utils.structured_adapter.html#module-sedona.utils.structured_adapter">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.utils.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.utils.html#module-sedona.utils.adapter">sedona.utils.adapter module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.utils.html#module-sedona.utils.spatial_rdd_parser">sedona.utils.spatial_rdd_parser module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.utils.html#module-sedona.utils">Module contents</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #ff5722" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Apache Sedona Python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">sedona.spark.sql.st_functions</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
    <div class="sedona-content-wrapper">
        
           <div itemprop="articleBody">
             
  <h1>Source code for sedona.spark.sql.st_functions</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed to the Apache Software Foundation (ASF) under one</span>
<span class="c1"># or more contributor license agreements.  See the NOTICE file</span>
<span class="c1"># distributed with this work for additional information</span>
<span class="c1"># regarding copyright ownership.  The ASF licenses this file</span>
<span class="c1"># to you under the Apache License, Version 2.0 (the</span>
<span class="c1"># &quot;License&quot;); you may not use this file except in compliance</span>
<span class="c1"># with the License.  You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing,</span>
<span class="c1"># software distributed under the License is distributed on an</span>
<span class="c1"># &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span>
<span class="c1"># KIND, either express or implied.  See the License for the</span>
<span class="c1"># specific language governing permissions and limitations</span>
<span class="c1"># under the License.</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">inspect</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pyspark.sql</span><span class="w"> </span><span class="kn">import</span> <span class="n">Column</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pyspark.sql.functions</span><span class="w"> </span><span class="kn">import</span> <span class="n">lit</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">sedona.spark.sql.dataframe_api</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">ColumnOrNameOrNumber</span><span class="p">,</span>
    <span class="n">call_sedona_function</span><span class="p">,</span>
    <span class="n">validate_argument_types</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">_call_st_function</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">call_sedona_function</span><span class="p">,</span> <span class="s2">&quot;st_functions&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="ExpandAddress">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ExpandAddress">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ExpandAddress</span><span class="p">(</span><span class="n">address</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">):</span>  <span class="c1"># noqa: N802</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Normalize an address string into its canonical forms.</span>

<span class="sd">    :param address: The address string or column to normalize.</span>
<span class="sd">    :return: An array of normalized address strings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ExpandAddress&quot;</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span></div>



<div class="viewcode-block" id="ParseAddress">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ParseAddress">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ParseAddress</span><span class="p">(</span><span class="n">address</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">):</span>  <span class="c1"># noqa: N802</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parse an address string into its components (label/value pairs).</span>

<span class="sd">    :param address: The address string or column to parse.</span>
<span class="sd">    :return: An array of maps with label/value pairs for address components.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ParseAddress&quot;</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span></div>



<div class="viewcode-block" id="GeometryType">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.GeometryType">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">GeometryType</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the type of the geometry as a string.</span>
<span class="sd">    This function also indicates if the geometry is measured, by returning a string of the form &#39;POINTM&#39;.</span>

<span class="sd">    :param geometry: Geometry column to calculate the dimension for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Type of geometry as a string column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;GeometryType&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_3DDistance">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_3DDistance">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_3DDistance</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the 3-dimensional minimum Cartesian distance between two geometry columns.</span>

<span class="sd">    :param a: One geometry column to use in the calculation.</span>
<span class="sd">    :type a: ColumnOrName</span>
<span class="sd">    :param b: Other geometry column to use in the calculation.</span>
<span class="sd">    :type b: ColumnOrName</span>
<span class="sd">    :return: Minimum cartesian distance between a and b as a double column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_3DDistance&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_AddMeasure">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_AddMeasure">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_AddMeasure</span><span class="p">(</span>
    <span class="n">geom</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">measureStart</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">measureEnd</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Interpolate measure values with the provided start and end points and return the result geometry.</span>

<span class="sd">    :param geom: Geometry column to use in the calculation.</span>
<span class="sd">    :type geom: ColumnOrName</span>
<span class="sd">    :param measureStart: Start point for the measure.</span>
<span class="sd">    :type measureStart: ColumnOrName</span>
<span class="sd">    :param measureEnd: End point for the measure.</span>
<span class="sd">    :type measureEnd: ColumnOrName</span>
<span class="sd">    :return: Result geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_AddMeasure&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">measureStart</span><span class="p">,</span> <span class="n">measureEnd</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_AddPoint">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_AddPoint">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_AddPoint</span><span class="p">(</span>
    <span class="n">line_string</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">point</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add a point to either the end of a linestring or a specified index.</span>
<span class="sd">    If index is not provided then point will be added to the end of line_string.</span>

<span class="sd">    :param line_string: Linestring geometry column to add point to.</span>
<span class="sd">    :type line_string: ColumnOrName</span>
<span class="sd">    :param point: Point geometry column to add to line_string.</span>
<span class="sd">    :type point: ColumnOrName</span>
<span class="sd">    :param index: 0-based index to insert point at in line_string, if None then point is appended to the end of line_string, defaults to None</span>
<span class="sd">    :type index: Optional[Union[ColumnOrName, int]], optional</span>
<span class="sd">    :return: Linestring geometry column with point added.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">line_string</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span> <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">line_string</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_AddPoint&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_LabelPoint">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_LabelPoint">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_LabelPoint</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">gridResolution</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrNameOrNumber</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">goodnessThreshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrNameOrNumber</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate an anchor point for a given geometry column.</span>

<span class="sd">    :param geometry: Input geometry column to calculate the anchor for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param gridResolution: Optional step size for grid search when determining the best anchor point.</span>
<span class="sd">                     Defaults to 2 if not provided.</span>
<span class="sd">    :type gridResolution: Optional[Union[ColumnOrNameOrNumber, int]], optional</span>
<span class="sd">    :param goodnessThreshold: Optional threshold for the minimum &quot;goodness&quot; value.</span>
<span class="sd">                              Determines when to stop refining the anchor search.</span>
<span class="sd">                              Defaults to 0.2 if not provided.</span>
<span class="sd">    :type goodnessThreshold: Optional[Union[ColumnOrNameOrNumber, float]], optional</span>
<span class="sd">    :return: Anchor point as a geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">gridResolution</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">goodnessThreshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,)</span>
    <span class="k">elif</span> <span class="n">goodnessThreshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">gridResolution</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">gridResolution</span><span class="p">,</span> <span class="n">goodnessThreshold</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_LabelPoint&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Area">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Area">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Area</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the area of a geometry.</span>

<span class="sd">    :param geometry: Geometry column to calculate the area of.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Area of geometry as a double column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Area&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_AreaSpheroid">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_AreaSpheroid">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_AreaSpheroid</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the area of a geometry using WGS84 spheroid.</span>

<span class="sd">    :param geometry: Geometry column to calculate the area of.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Area of geometry as a double column. Unit is meter.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_AreaSpheroid&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_AsBinary">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_AsBinary">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_AsBinary</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate the Well-Known Binary (WKB) representation of a geometry.</span>

<span class="sd">    :param geometry: Geometry column to generate WKB for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Well-Known Binary representation of geometry as a binary column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_AsBinary&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_AsEWKB">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_AsEWKB">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_AsEWKB</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate the Extended Well-Known Binary representation of a geometry.</span>
<span class="sd">    As opposed to WKB, EWKB will include the SRID of the geometry.</span>

<span class="sd">    :param geometry: Geometry to generate EWKB for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Extended Well-Known Binary representation of geometry as a binary column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_AsEWKB&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_AsHEXEWKB">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_AsHEXEWKB">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_AsHEXEWKB</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">endian</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate the Extended Well-Known Binary representation of a geometry as Hex string.</span>

<span class="sd">    :param geometry: Geometry to generate EWKB for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Extended Well-Known Binary representation of geometry as Hex string.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">)</span> <span class="k">if</span> <span class="n">endian</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">endian</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_AsHEXEWKB&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_AsEWKT">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_AsEWKT">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_AsEWKT</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate the Extended Well-Known Text representation of a geometry column.</span>
<span class="sd">    As opposed to WKT, EWKT will include the SRID of the geometry.</span>

<span class="sd">    :param geometry: Geometry column to generate EWKT for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Extended Well-Known Text representation of geometry as a string column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_AsEWKT&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_AsGeoJSON">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_AsGeoJSON">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_AsGeoJSON</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate the GeoJSON style representation of a geometry column.</span>

<span class="sd">    :param geometry: Geometry column to generate GeoJSON for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: GeoJSON representation of geometry as a string column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">)</span> <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_AsGeoJSON&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_AsGML">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_AsGML">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_AsGML</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate the Geography Markup Language (GML) representation of a</span>
<span class="sd">    geometry column.</span>

<span class="sd">    :param geometry: Geometry column to generate GML for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: GML representation of geometry as a string column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_AsGML&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_AsKML">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_AsKML">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_AsKML</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate the KML representation of a geometry column.</span>

<span class="sd">    :param geometry: Geometry column to generate KML for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: KML representation of geometry as a string column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_AsKML&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_AsText">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_AsText">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_AsText</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate the Well-Known Text (WKT) representation of a geometry column.</span>

<span class="sd">    :param geometry: Geometry column to generate WKT for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: WKT representation of geometry as a string column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_AsText&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Azimuth">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Azimuth">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Azimuth</span><span class="p">(</span><span class="n">point_a</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">point_b</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the azimuth for two point columns in radians.</span>

<span class="sd">    :param point_a: One point geometry column to use for the calculation.</span>
<span class="sd">    :type point_a: ColumnOrName</span>
<span class="sd">    :param point_b: Other point geometry column to use for the calculation.</span>
<span class="sd">    :type point_b: ColumnOrName</span>
<span class="sd">    :return: Azimuth for point_a and point_b in radians as a double column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Azimuth&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">point_a</span><span class="p">,</span> <span class="n">point_b</span><span class="p">))</span></div>



<div class="viewcode-block" id="barrier">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.barrier">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">barrier</span><span class="p">(</span><span class="n">expression</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Prevent filter pushdown and control predicate evaluation order in complex spatial joins.</span>
<span class="sd">    This function creates an optimization barrier by evaluating boolean expressions at runtime.</span>

<span class="sd">    :param expression: Boolean expression string to evaluate</span>
<span class="sd">    :type expression: ColumnOrName</span>
<span class="sd">    :param args: Variable name and value pairs (var_name1, var_value1, var_name2, var_value2, ...)</span>
<span class="sd">    :return: Boolean result of the expression evaluation</span>
<span class="sd">    :rtype: Column</span>

<span class="sd">    Example:</span>
<span class="sd">        df.where(barrier(&#39;rating &gt; 4.0 AND stars &gt;= 4&#39;,</span>
<span class="sd">                        &#39;rating&#39;, col(&#39;r.rating&#39;),</span>
<span class="sd">                        &#39;stars&#39;, col(&#39;h.stars&#39;)))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;barrier&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">expression</span><span class="p">,)</span> <span class="o">+</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_BestSRID">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_BestSRID">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_BestSRID</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Estimates the best SRID (EPSG code) of the geometry.</span>

<span class="sd">    :param geometry: Geometry column to calculate the boundary for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: SRID as an Integer</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_BestSRID&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_ShiftLongitude">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_ShiftLongitude">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_ShiftLongitude</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Shifts longitudes between -180..0 degrees to 180..360 degrees and vice versa.</span>

<span class="sd">    :param geometry: Geometry column.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Shifted geometry</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_ShiftLongitude&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Boundary">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Boundary">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Boundary</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the closure of the combinatorial boundary of a geometry column.</span>

<span class="sd">    :param geometry: Geometry column to calculate the boundary for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Boundary of the input geometry as a geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Boundary&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Buffer">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Buffer">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Buffer</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">buffer</span><span class="p">:</span> <span class="n">ColumnOrNameOrNumber</span><span class="p">,</span>
    <span class="n">useSpheroid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">parameters</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate a geometry that represents all points whose distance from the</span>
<span class="sd">    input geometry column is equal to or less than a given amount.</span>

<span class="sd">    :param geometry: Input geometry column to buffer.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param buffer: Either a column or value for the amount to buffer the input geometry by.</span>
<span class="sd">    :type buffer: ColumnOrNameOrNumber</span>
<span class="sd">    :return: Buffered geometry as a geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">parameters</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">useSpheroid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">buffer</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">useSpheroid</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">useSpheroid</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Buffer&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_BuildArea">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_BuildArea">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_BuildArea</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a geometry described by the constituent linework of the input</span>
<span class="sd">    geometry column.</span>

<span class="sd">    :param geometry: Linestring or multilinestring geometry column to use as input.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Area formed by geometry as a geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_BuildArea&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Centroid">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Centroid">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Centroid</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the centroid of the given geometry column.</span>

<span class="sd">    :param geometry: Geometry column to calculate a centroid for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Centroid of geometry as a point geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Centroid&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Collect">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Collect">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Collect</span><span class="p">(</span><span class="o">*</span><span class="n">geometries</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Collect multiple geometry columns or an array of geometries into a single</span>
<span class="sd">    multi-geometry or geometry collection.</span>

<span class="sd">    :param geometries: Either a single geometry column that holds an array of geometries or multiple geometry columns.</span>
<span class="sd">    :return: If the types of geometries are homogeneous then a multi-geometry is returned, otherwise a geometry collection is returned.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">geometries</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Collect&quot;</span><span class="p">,</span> <span class="n">geometries</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Collect&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">geometries</span><span class="p">])</span></div>



<div class="viewcode-block" id="ST_CollectionExtract">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_CollectionExtract">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_CollectionExtract</span><span class="p">(</span>
    <span class="n">collection</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">geom_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract a specific type of geometry from a geometry collection column</span>
<span class="sd">    as a multi-geometry column.</span>

<span class="sd">    :param collection: Column for the geometry collection.</span>
<span class="sd">    :type collection: ColumnOrName</span>
<span class="sd">    :param geom_type: Type of geometry to extract where 1 is point, 2 is linestring, and 3 is polygon, if None then the highest dimension geometry is extracted, defaults to None</span>
<span class="sd">    :type geom_type: Optional[Union[ColumnOrName, int]], optional</span>
<span class="sd">    :return: Multi-geometry column containing all geometry from collection of the selected type.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">collection</span><span class="p">,)</span> <span class="k">if</span> <span class="n">geom_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">geom_type</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_CollectionExtract&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_ClosestPoint">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_ClosestPoint">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_ClosestPoint</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the 2-dimensional point on geom1 that is closest to geom2.</span>
<span class="sd">    This is the first point of the shortest line between the geometries.</span>

<span class="sd">    :param a: Geometry column to use in the calculation.</span>
<span class="sd">    :type a: ColumnOrName</span>
<span class="sd">    :param b: Geometry column to use in the calculation.</span>
<span class="sd">    :type b: ColumnOrName</span>
<span class="sd">    :return: the 2-dimensional point on a that is closest to b.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_ClosestPoint&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_ConcaveHull">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_ConcaveHull">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_ConcaveHull</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">pctConvex</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">allowHoles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate the cancave hull of a geometry column.</span>

<span class="sd">    :param geometry: Geometry column to generate a cancave hull for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param pctConvex: value between 0 and 1, controls the concaveness of the computed hull.</span>
<span class="sd">    :type pctConvex: Union[ColumnOrName, float]</span>
<span class="sd">    :param allowHoles: The computed hull will not contain holes unless allowHoles is specified as true</span>
<span class="sd">    :type allowHoles: Optional[Union[ColumnOrName, bool]], optional</span>
<span class="sd">    :return: Concave hull of geometry as a geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">pctConvex</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">allowHoles</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">else</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">pctConvex</span><span class="p">,</span> <span class="n">allowHoles</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_ConcaveHull&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_ConvexHull">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_ConvexHull">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_ConvexHull</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate the convex hull of a geometry column.</span>

<span class="sd">    :param geometry: Geometry column to generate a convex hull for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Convex hull of geometry as a geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_ConvexHull&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_CrossesDateLine">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_CrossesDateLine">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_CrossesDateLine</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check whether geometry a crosses the International Date Line.</span>

<span class="sd">    :param a: Geometry to check crossing with.</span>
<span class="sd">    :type a: ColumnOrName</span>
<span class="sd">    :return: True if geometry a cross the dateline.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_CrossesDateLine&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_Dimension">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Dimension">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Dimension</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the inherent dimension of a geometry column.</span>

<span class="sd">    :param geometry: Geometry column to calculate the dimension for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Dimension of geometry as an integer column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Dimension&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Difference">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Difference">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Difference</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the difference of two geometry columns. This difference</span>
<span class="sd">    is not symmetric. It only returns the part of geometry a that is not</span>
<span class="sd">    in b.</span>

<span class="sd">    :param a: Geometry column to use in the calculation.</span>
<span class="sd">    :type a: ColumnOrName</span>
<span class="sd">    :param b: Geometry column to subtract from geometry column a.</span>
<span class="sd">    :type b: ColumnOrName</span>
<span class="sd">    :return: Part of geometry a that is not in b as a geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Difference&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_Distance">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Distance">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Distance</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the minimum cartesian distance between two geometry columns.</span>

<span class="sd">    :param a: Geometry column to use in the calculation.</span>
<span class="sd">    :type a: ColumnOrName</span>
<span class="sd">    :param b: Other geometry column to use in the calculation.</span>
<span class="sd">    :type b: ColumnOrName</span>
<span class="sd">    :return: Two-dimensional cartesian distance between a and b as a double column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Distance&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_DistanceSpheroid">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_DistanceSpheroid">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_DistanceSpheroid</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the geodesic distance between two geometry columns using WGS84 spheroid.</span>

<span class="sd">    :param a: Geometry column to use in the calculation.</span>
<span class="sd">    :type a: ColumnOrName</span>
<span class="sd">    :param b: Other geometry column to use in the calculation.</span>
<span class="sd">    :type b: ColumnOrName</span>
<span class="sd">    :return: Two-dimensional geodesic distance between a and b as a double column. Unit is meter.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_DistanceSpheroid&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_DistanceSphere">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_DistanceSphere">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_DistanceSphere</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">radius</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">6371008.0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the haversine/great-circle distance between two geometry columns using a given radius.</span>

<span class="sd">    :param a: Geometry column to use in the calculation.</span>
<span class="sd">    :type a: ColumnOrName</span>
<span class="sd">    :param b: Other geometry column to use in the calculation.</span>
<span class="sd">    :type b: ColumnOrName</span>
<span class="sd">    :param radius: Radius of the sphere, defaults to 6371008.0</span>
<span class="sd">    :type radius: Optional[Union[ColumnOrName, float]], optional</span>
<span class="sd">    :return: Two-dimensional haversine/great-circle distance between a and b as a double column. Unit is meter.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_DistanceSphere&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">radius</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_Dump">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Dump">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Dump</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns an array of geometries that are members of a multi-geometry</span>
<span class="sd">    or geometry collection column. If the input geometry is a regular geometry</span>
<span class="sd">    then the geometry is returned inside of a single element array.</span>

<span class="sd">    :param geometry: Geometry column to dump.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Array of geometries column comprised of the members of geometry.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Dump&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_DumpPoints">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_DumpPoints">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_DumpPoints</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the list of points of a geometry column. Specifically, return</span>
<span class="sd">    the vertices of the input geometry as an array.</span>

<span class="sd">    :param geometry: Geometry column to dump the points of.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Array of point geometry column comprised of the vertices of geometry.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_DumpPoints&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_EndPoint">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_EndPoint">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_EndPoint</span><span class="p">(</span><span class="n">line_string</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the last point of a linestring geometry column.</span>

<span class="sd">    :param line_string: Linestring geometry column to get the end point of.</span>
<span class="sd">    :type line_string: ColumnOrName</span>
<span class="sd">    :return: The last point of the linestring geometry column as a point geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_EndPoint&quot;</span><span class="p">,</span> <span class="n">line_string</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Envelope">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Envelope">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Envelope</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the envelope boundary of a geometry column.</span>

<span class="sd">    :param geometry: Geometry column to calculate the envelope of.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Envelope of geometry as a geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Envelope&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Expand">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Expand">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Expand</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">deltaX_uniformDelta</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">deltaY</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">deltaZ</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Expand the given geometry column by a constant unit in each direction</span>

<span class="sd">    :param geometry: Geometry column to calculate the envelope of.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param deltaX_uniformDelta: it is either deltaX or uniformDelta depending on the number of arguments provided</span>
<span class="sd">    :type deltaX_uniformDelta: Union[ColumnOrName, float]</span>
<span class="sd">    :param deltaY: Constant unit of deltaY</span>
<span class="sd">    :type deltaY: Union[ColumnOrName, float]</span>
<span class="sd">    :param deltaZ: Constant unit of deltaZ</span>
<span class="sd">    :type deltaZ: Union[ColumnOrName, float]</span>
<span class="sd">    :return: Envelope of geometry as a geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">deltaZ</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">deltaX_uniformDelta</span><span class="p">,</span> <span class="n">deltaY</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deltaY</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">deltaX_uniformDelta</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">deltaX_uniformDelta</span><span class="p">,</span> <span class="n">deltaY</span><span class="p">,</span> <span class="n">deltaZ</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Expand&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_ExteriorRing">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_ExteriorRing">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_ExteriorRing</span><span class="p">(</span><span class="n">polygon</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get a linestring representing the exterior ring of a polygon geometry</span>
<span class="sd">    column.</span>

<span class="sd">    :param polygon: Polygon geometry column to get the exterior ring of.</span>
<span class="sd">    :type polygon: ColumnOrName</span>
<span class="sd">    :return: Exterior ring of polygon as a linestring geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_ExteriorRing&quot;</span><span class="p">,</span> <span class="n">polygon</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_FlipCoordinates">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_FlipCoordinates">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_FlipCoordinates</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Flip the X and Y coordinates of a geometry column.</span>

<span class="sd">    :param geometry: Geometry column to flip coordinates for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Geometry column identical to geometry except with flipped coordinates.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_FlipCoordinates&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Force_2D">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Force_2D">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Force_2D</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Force the geometry column to only output two dimensional representations.</span>

<span class="sd">    :param geometry: Geometry column to force to be 2D.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Geometry column identical to geometry except with only X and Y coordinates.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Force_2D&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Force2D">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Force2D">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Force2D</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Force the geometry column to only output two dimensional representations.</span>

<span class="sd">    :param geometry: Geometry column to force to be 2D.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Geometry column identical to geometry except with only X and Y coordinates.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Force2D&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_GeneratePoints">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_GeneratePoints">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_GeneratePoints</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">numPoints</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate random points in given geometry.</span>

<span class="sd">    :param geometry: Geometry column to hash.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param numPoints: Precision level to hash geometry at, given as an integer or an integer column.</span>
<span class="sd">    :type numPoints: Union[ColumnOrName, int]</span>
<span class="sd">    :return: Generate random points in given geometry</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">numPoints</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">numPoints</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_GeneratePoints&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_GeoHash">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_GeoHash">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_GeoHash</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">precision</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the geohash of a geometry column at a given precision level.</span>

<span class="sd">    :param geometry: Geometry column to hash.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param precision: Precision level to hash geometry at, given as an integer or an integer column.</span>
<span class="sd">    :type precision: Union[ColumnOrName, int]</span>
<span class="sd">    :return: Geohash of geometry as a string column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_GeoHash&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">precision</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_GeometricMedian">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_GeometricMedian">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_GeometricMedian</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">tolerance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
    <span class="n">max_iter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="n">fail_if_not_converged</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes the approximate geometric median of a MultiPoint geometry using the Weiszfeld algorithm.</span>
<span class="sd">    The geometric median provides a centrality measure that is less sensitive to outlier points than the centroid.</span>
<span class="sd">    The algorithm will iterate until the distance change between successive iterations is less than the</span>
<span class="sd">    supplied `tolerance` parameter. If this condition has not been met after `maxIter` iterations, the function will</span>
<span class="sd">    produce an error and exit, unless `failIfNotConverged` is set to `false`. If a `tolerance` value is not provided,</span>
<span class="sd">    a default `tolerance` value is `1e-6`.</span>

<span class="sd">    :param geometry: MultiPoint or Point geometry.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param tolerance: Distance limit change between successive iterations, defaults to 1e-6.</span>
<span class="sd">    :type tolerance: Optional[Union[ColumnOrName, float]], optional</span>
<span class="sd">    :param max_iter: Max number of iterations, defaults to 1000.</span>
<span class="sd">    :type max_iter: Optional[Union[ColumnOrName, int]], optional</span>
<span class="sd">    :param fail_if_not_converged: Generate error if not converged within given tolerance and number of iterations, defaults to False</span>
<span class="sd">    :type fail_if_not_converged: Optional[Union[ColumnOrName, boolean]], optional</span>
<span class="sd">    :return: Point geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">,</span> <span class="n">fail_if_not_converged</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_GeometricMedian&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_GeometryN">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_GeometryN">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_GeometryN</span><span class="p">(</span><span class="n">multi_geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the geometry at index n (0-th based) of a multi-geometry column.</span>

<span class="sd">    :param multi_geometry: Multi-geometry column to get from.</span>
<span class="sd">    :type multi_geometry: ColumnOrName</span>
<span class="sd">    :param n: Index to select, given as an integer or integer column, 0-th based index, returns null if index is greater than maximum index.</span>
<span class="sd">    :type n: Union[ColumnOrName, int]</span>
<span class="sd">    :return: Geometry located at index n in multi_geometry as a geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    :raises ValueError: If</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Index n for ST_GeometryN must by &gt;= 0: </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> &lt; 0&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_GeometryN&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">multi_geometry</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_GeometryType">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_GeometryType">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_GeometryType</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the type of geometry in a given geometry column.</span>

<span class="sd">    :param geometry: Geometry column to find the type for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Type of geometry as a string column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_GeometryType&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_H3CellDistance">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_H3CellDistance">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_H3CellDistance</span><span class="p">(</span>
    <span class="n">cell1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">cell2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Cover Geometry with H3 Cells and return a List of Long type cell IDs</span>
<span class="sd">    :param cell: start cell</span>
<span class="sd">    :type cell: long</span>
<span class="sd">    :param k: end cell</span>
<span class="sd">    :type k: int</span>
<span class="sd">    :return: distance between cells</span>
<span class="sd">    :rtype: Long</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">cell1</span><span class="p">,</span> <span class="n">cell2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_H3CellDistance&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_H3CellIDs">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_H3CellIDs">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_H3CellIDs</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">full_cover</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">bool</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Cover Geometry with H3 Cells and return a List of Long type cell IDs</span>
<span class="sd">    :param geometry: Geometry column to generate cell IDs</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param level: value between 1 and 15, controls the size of the cells used for coverage. With a bigger level, the cells will be smaller, the coverage will be more accurate, but the result size will be exponentially increasing.</span>
<span class="sd">    :type level: int</span>
<span class="sd">    :param full_cover: ColumnOrName</span>
<span class="sd">    :type full_cover: int</span>
<span class="sd">    :return: List of cellIDs</span>
<span class="sd">    :rtype: List[long]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">full_cover</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_H3CellIDs&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_H3KRing">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_H3KRing">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_H3KRing</span><span class="p">(</span>
    <span class="n">cell</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">k</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">exact_ring</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">bool</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Cover Geometry with H3 Cells and return a List of Long type cell IDs</span>
<span class="sd">    :param cell: original cell</span>
<span class="sd">    :type cell: long</span>
<span class="sd">    :param k: the k number of rings spread from the original cell</span>
<span class="sd">    :type k: int</span>
<span class="sd">    :param exact_ring: if exactDistance is true, it will only return the cells on the exact kth ring, else will return all 0 - kth neighbors</span>
<span class="sd">    :type exact_ring: bool</span>
<span class="sd">    :return: List of cellIDs</span>
<span class="sd">    :rtype: List[long]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">exact_ring</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_H3KRing&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_H3ToGeom">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_H3ToGeom">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_H3ToGeom</span><span class="p">(</span><span class="n">cells</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">list</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Cover Geometry with H3 Cells and return a List of Long type cell IDs</span>
<span class="sd">    :param cells: h3 cells</span>
<span class="sd">    :return: the reversed multipolygon</span>
<span class="sd">    :rtype: Geometry</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_H3ToGeom&quot;</span><span class="p">,</span> <span class="n">cells</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_InteriorRingN">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_InteriorRingN">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_InteriorRingN</span><span class="p">(</span><span class="n">polygon</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the index n (0-th based) interior ring of a polygon geometry column.</span>

<span class="sd">    :param polygon: Polygon geometry column to get an interior ring from.</span>
<span class="sd">    :type polygon: ColumnOrName</span>
<span class="sd">    :param n: Index of interior ring to return as either an integer or integer column, 0-th based.</span>
<span class="sd">    :type n: Union[ColumnOrName, int]</span>
<span class="sd">    :raises ValueError: If n is an integer and less than 0.</span>
<span class="sd">    :return: Interior ring at index n as a linestring geometry column or null if n is greater than maximum index</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Index n for ST_InteriorRingN must by &gt;= 0: </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> &lt; 0&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_InteriorRingN&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_Intersection">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Intersection">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Intersection</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the intersection of two geometry columns.</span>

<span class="sd">    :param a: One geometry column to use in the calculation.</span>
<span class="sd">    :type a: ColumnOrName</span>
<span class="sd">    :param b: Other geometry column to use in the calculation.</span>
<span class="sd">    :type b: ColumnOrName</span>
<span class="sd">    :return: Intersection of a and b as a geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Intersection&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_IsClosed">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_IsClosed">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_IsClosed</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if the linestring in a geometry column is closed (its end point is equal to its start point).</span>

<span class="sd">    :param geometry: Linestring geometry column to check.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: True if geometry is closed and False otherwise as a boolean column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_IsClosed&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_IsEmpty">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_IsEmpty">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_IsEmpty</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if the geometry in a geometry column is an empty geometry.</span>

<span class="sd">    :param geometry: Geometry column to check.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: True if the geometry is empty and False otherwise as a boolean column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_IsEmpty&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_IsPolygonCW">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_IsPolygonCW">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_IsPolygonCW</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if the Polygon or MultiPolygon use a clockwise orientation for exterior ring and counter-clockwise</span>
<span class="sd">    orientation for interior ring.</span>

<span class="sd">    :param geometry: Geometry column to check.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: True if the geometry is empty and False otherwise as a boolean column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_IsPolygonCW&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_IsRing">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_IsRing">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_IsRing</span><span class="p">(</span><span class="n">line_string</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if a linestring geometry is both closed and simple.</span>

<span class="sd">    :param line_string: Linestring geometry column to check.</span>
<span class="sd">    :type line_string: ColumnOrName</span>
<span class="sd">    :return: True if the linestring is both closed and simple and False otherwise as a boolean column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_IsRing&quot;</span><span class="p">,</span> <span class="n">line_string</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_IsSimple">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_IsSimple">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_IsSimple</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if a geometry&#39;s only intersections are at boundary points.</span>

<span class="sd">    :param geometry: Geometry column to check in.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: True if geometry is simple and False otherwise as a boolean column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_IsSimple&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_IsValid">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_IsValid">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_IsValid</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">flag</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if a geometry is well formed.</span>

<span class="sd">    :param geometry: Geometry column to check in.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param flag: Optional flag to modify behavior of the validity check.</span>
<span class="sd">    :type flag: Optional[Union[ColumnOrName, int]]</span>
<span class="sd">    :return: True if geometry is well formed and False otherwise as a boolean column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,)</span> <span class="k">if</span> <span class="n">flag</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_IsValid&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_IsValidDetail">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_IsValidDetail">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_IsValidDetail</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">flag</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a row of valid, reason and location. valid defines the validity of geometry, reason defines the</span>
<span class="sd">    reason why it is not valid and location defines the location where it is not valid</span>
<span class="sd">    If the geometry is valid then it will return null for reason and location</span>

<span class="sd">    :param geometry: Geometry column to validate.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param flag: Optional flag to modify behavior of the validity check.</span>
<span class="sd">    :type flag: Optional[Union[ColumnOrName, int]]</span>
<span class="sd">    :return: Row of valid, reason and location</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,)</span> <span class="k">if</span> <span class="n">flag</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_IsValidDetail&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_IsValidTrajectory">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_IsValidTrajectory">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_IsValidTrajectory</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tests if a geometry encodes a valid trajectory. A valid trajectory is represented as a LINESTRING with measures</span>
<span class="sd">    (M values). The measure values must increase from each vertex to the next.</span>

<span class="sd">    :param geometry: Geometry column to validate.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: True if the geometry is valid trajectory and False otherwise as a boolean column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_IsValidTrajectory&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">geometry</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_IsValidReason">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_IsValidReason">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_IsValidReason</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">flag</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Provides a text description of why a geometry is not valid or states that it is valid.</span>
<span class="sd">    An optional flag parameter can be provided for additional options.</span>

<span class="sd">    :param geometry: Geometry column to validate.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param flag: Optional flag to modify behavior of the validity check.</span>
<span class="sd">    :type flag: Optional[Union[ColumnOrName, int]]</span>
<span class="sd">    :return: Description of validity as a string column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,)</span> <span class="k">if</span> <span class="n">flag</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_IsValidReason&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Length">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Length">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Length</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the length of a linestring geometry.</span>

<span class="sd">    :param geometry: Linestring geometry column to calculate length for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Length of geometry as a double column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Length&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Length2D">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Length2D">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Length2D</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the length of a linestring geometry.</span>

<span class="sd">    :param geometry: Linestring geometry column to calculate length for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Length of geometry as a double column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Length2D&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_LengthSpheroid">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_LengthSpheroid">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_LengthSpheroid</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the perimeter of a geometry using WGS84 spheroid.</span>

<span class="sd">    :param geometry: Geometry column to calculate length for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: perimeter of geometry as a double column. Unit is meter.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_LengthSpheroid&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_LineFromMultiPoint">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_LineFromMultiPoint">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_LineFromMultiPoint</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates a LineString from a MultiPoint geometry.</span>

<span class="sd">    :param geometry: MultiPoint geometry column to create LineString from.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: LineString geometry of a MultiPoint geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_LineFromMultiPoint&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_LineInterpolatePoint">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_LineInterpolatePoint">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_LineInterpolatePoint</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">fraction</span><span class="p">:</span> <span class="n">ColumnOrNameOrNumber</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate a point that is interpolated along a linestring.</span>

<span class="sd">    :param geometry: Linestring geometry column to interpolate from.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param fraction: Fraction of total length along geometry to generate a point for.</span>
<span class="sd">    :type fraction: ColumnOrNameOrNumber</span>
<span class="sd">    :return: Interpolated point as a point geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_LineInterpolatePoint&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">fraction</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_LineLocatePoint">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_LineLocatePoint">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_LineLocatePoint</span><span class="p">(</span><span class="n">linestring</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">point</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a double between 0 and 1 representing the location of the closest point on a LineString to the given Point, as a fraction of 2d line length.</span>

<span class="sd">    :param linestring: Linestring geometry column to locate point on.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param point: Point geometry column.</span>
<span class="sd">    :type geometry: ColumnOrNameOrNumber</span>
<span class="sd">    :return: double between 0 and 1 as a fraction of 2d line length.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_LineLocatePoint&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">linestring</span><span class="p">,</span> <span class="n">point</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_LineMerge">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_LineMerge">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_LineMerge</span><span class="p">(</span><span class="n">multi_line_string</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sew together the constituent line work of a multilinestring into a</span>
<span class="sd">    single linestring.</span>

<span class="sd">    :param multi_line_string: Multilinestring geometry column to merge.</span>
<span class="sd">    :type multi_line_string: ColumnOrName</span>
<span class="sd">    :return: Linestring geometry column resulting from the merger of multi_line_string.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_LineMerge&quot;</span><span class="p">,</span> <span class="n">multi_line_string</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_LineSegments">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_LineSegments">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_LineSegments</span><span class="p">(</span>
    <span class="n">geom</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">lenient</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert multi-coordinate LineString into an array of LineStrings that contain exactly 2 points.</span>

<span class="sd">    @param geom: input LineString geometry column.</span>
<span class="sd">    @param lenient: suppresses exception</span>
<span class="sd">    @return: array of LineStrings</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">lenient</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lenient</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geom</span><span class="p">,)</span>

    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_LineSegments&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_LineSubstring">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_LineSubstring">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_LineSubstring</span><span class="p">(</span>
    <span class="n">line_string</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">start_fraction</span><span class="p">:</span> <span class="n">ColumnOrNameOrNumber</span><span class="p">,</span>
    <span class="n">end_fraction</span><span class="p">:</span> <span class="n">ColumnOrNameOrNumber</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a substring of a linestring geometry column.</span>

<span class="sd">    :param line_string: Linestring geometry column to generate from.</span>
<span class="sd">    :type line_string: ColumnOrName</span>
<span class="sd">    :param start_fraction: Fraction of linestring to start from for the resulting substring as either a number or numeric column.</span>
<span class="sd">    :type start_fraction: ColumnOrNameOrNumber</span>
<span class="sd">    :param end_fraction: Fraction of linestring to end at for the resulting substring as either a number or numeric column.</span>
<span class="sd">    :type end_fraction: ColumnOrNameOrNumber</span>
<span class="sd">    :return: Smaller linestring that runs from start_fraction to end_fraction of line_string as a linestring geometry column, will be null if either start_fraction or end_fraction are outside the interval [0, 1].</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span>
        <span class="s2">&quot;ST_LineSubstring&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">line_string</span><span class="p">,</span> <span class="n">start_fraction</span><span class="p">,</span> <span class="n">end_fraction</span><span class="p">)</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="ST_LocateAlong">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_LocateAlong">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_LocateAlong</span><span class="p">(</span>
    <span class="n">geom</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">measure</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">offset</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;return locations along a measure geometry that have the given measure value.</span>

<span class="sd">    :param geom:</span>
<span class="sd">    :type geom: ColumnOrName</span>
<span class="sd">    :param measure:</span>
<span class="sd">    :type measure: Union[ColumnOrName, float]</span>
<span class="sd">    :param offset:</span>
<span class="sd">    :type offset: Union[ColumnOrNameOrNumber, float]</span>
<span class="sd">    :return: Locations along a measure geometry that have the given measure value.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">measure</span><span class="p">)</span> <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">measure</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_LocateAlong&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_LongestLine">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_LongestLine">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_LongestLine</span><span class="p">(</span><span class="n">geom1</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">geom2</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the longest line between the two geometries</span>

<span class="sd">    :param geom1:</span>
<span class="sd">    :type geom1: ColumnOrName</span>
<span class="sd">    :param geom2:</span>
<span class="sd">    :type geom2: ColumnOrName</span>
<span class="sd">    :return: Longest line between the two input geometries</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_LongestLine&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">geom1</span><span class="p">,</span> <span class="n">geom2</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_HasZ">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_HasZ">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_HasZ</span><span class="p">(</span><span class="n">geom</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check whether geometry has Z coordinate</span>

<span class="sd">    :param geom: Geometry</span>
<span class="sd">    :type geom: ColumnOrName</span>
<span class="sd">    :return: True if geometry has Z coordinate, else False</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_HasZ&quot;</span><span class="p">,</span> <span class="n">geom</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_HasM">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_HasM">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_HasM</span><span class="p">(</span><span class="n">geom</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check whether geometry has M coordinate</span>

<span class="sd">    :param geom: Geometry</span>
<span class="sd">    :type geom: ColumnOrName</span>
<span class="sd">    :return: True if geometry has M coordinate, else False</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_HasM&quot;</span><span class="p">,</span> <span class="n">geom</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_M">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_M">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_M</span><span class="p">(</span><span class="n">geom</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the M coordinate of a point geometry.</span>

<span class="sd">    :param point: Point geometry column to get the coordinate for.</span>
<span class="sd">    :type point: ColumnOrName</span>
<span class="sd">    :return: M coordinate of the point geometry as a double column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_M&quot;</span><span class="p">,</span> <span class="n">geom</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_MMin">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_MMin">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_MMin</span><span class="p">(</span><span class="n">geom</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the minimum M coordinate of a geometry.</span>

<span class="sd">    :param geometry: Geometry column to get the minimum M coordinate from.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Minimum M coordinate for the geometry as a double column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_MMin&quot;</span><span class="p">,</span> <span class="n">geom</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_MMax">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_MMax">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_MMax</span><span class="p">(</span><span class="n">geom</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the maximum M coordinate of a geometry.</span>

<span class="sd">    :param geometry: Geometry column to get the maximum M coordinate from.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Minimum M coordinate for the geometry as a double column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_MMax&quot;</span><span class="p">,</span> <span class="n">geom</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_MakeLine">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_MakeLine">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_MakeLine</span><span class="p">(</span><span class="n">geom1</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">geom2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates a LineString containing the points of Point, MultiPoint, or LineString geometries. Other geometry types cause an error.</span>

<span class="sd">    :param geom1: Geometry column to convert.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param geom2: Geometry column to convert. If geoms is empty, then geom1 is an array of geometries.</span>
<span class="sd">    :type geometry: Optional[ColumnOrName], optional</span>
<span class="sd">    :return: LineString geometry column created from the input geometries.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geom1</span><span class="p">,)</span> <span class="k">if</span> <span class="n">geom2</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">geom1</span><span class="p">,</span> <span class="n">geom2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_MakeLine&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Perimeter">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Perimeter">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Perimeter</span><span class="p">(</span>
    <span class="n">geom</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">use_spheroid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">lenient</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the perimeter of a Polygon/MultiPolygon geometries. Otherwise, returns 0</span>

<span class="sd">    @param geom: Polygonal geometry</span>
<span class="sd">    @param use_spheroid: Use Spheroid</span>
<span class="sd">    @param lenient: suppresses the exception</span>
<span class="sd">    @return: Perimeter of a Polygon/MultiPolygon geometries</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">use_spheroid</span><span class="p">,</span> <span class="n">lenient</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">lenient</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">use_spheroid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geom</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">use_spheroid</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Perimeter&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Perimeter2D">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Perimeter2D">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Perimeter2D</span><span class="p">(</span>
    <span class="n">geom</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">use_spheroid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">lenient</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the perimeter of a Polygon/MultiPolygon geometries. Otherwise, returns 0</span>

<span class="sd">    @param geom: Polygonal geometry</span>
<span class="sd">    @param use_spheroid: Use Spheroid</span>
<span class="sd">    @param lenient: suppresses the exception</span>
<span class="sd">    @return: Perimeter of a Polygon/MultiPolygon geometries</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">use_spheroid</span><span class="p">,</span> <span class="n">lenient</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">lenient</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">use_spheroid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geom</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">use_spheroid</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Perimeter2D&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Points">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Points">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Points</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates a MultiPoint geometry consisting of all the coordinates of the input geometry</span>

<span class="sd">    :param geometry: input geometry.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Multipoint geometry</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Points&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">geometry</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_Polygon">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Polygon">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Polygon</span><span class="p">(</span><span class="n">line_string</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">srid</span><span class="p">:</span> <span class="n">ColumnOrNameOrNumber</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a polygon built from the given LineString and sets the spatial reference system from the srid.</span>

<span class="sd">    :param line_string: Closed linestring geometry column that describes the exterior ring of the polygon.</span>
<span class="sd">    :type line_string: ColumnOrName</span>
<span class="sd">    :param srid: Spatial reference system identifier.</span>
<span class="sd">    :type srid: ColumnOrNameOrNumber</span>
<span class="sd">    :return: Polygon geometry column created from the input linestring.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Polygon&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">line_string</span><span class="p">,</span> <span class="n">srid</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_Polygonize">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Polygonize">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Polygonize</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates a GeometryCollection composed of polygons that are formed from the linework of a set of input geometries.</span>

<span class="sd">    :param geometry: input geometry of type GeometryCollection</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: GeometryCollection geometry column created from the input geometry.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Polygonize&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">geometry</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_Project">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Project">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Project</span><span class="p">(</span>
    <span class="n">geom</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">distance</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">azimuth</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">lenient</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculates a new point location given a starting point, distance, and direction (azimuth).</span>

<span class="sd">    @param geom:</span>
<span class="sd">    @param distance:</span>
<span class="sd">    @param azimuth:</span>
<span class="sd">    @param lenient:</span>
<span class="sd">    @return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">azimuth</span><span class="p">,</span> <span class="n">lenient</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lenient</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">azimuth</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Project&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_MakePolygon">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_MakePolygon">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_MakePolygon</span><span class="p">(</span>
    <span class="n">line_string</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">holes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a polygon geometry from a linestring describing the exterior ring as well as an array of linestrings describing holes.</span>

<span class="sd">    :param line_string: Closed linestring geometry column that describes the exterior ring of the polygon.</span>
<span class="sd">    :type line_string: ColumnOrName</span>
<span class="sd">    :param holes: Optional column for an array of closed geometry columns that describe holes in the polygon, defaults to None.</span>
<span class="sd">    :type holes: Optional[ColumnOrName], optional</span>
<span class="sd">    :return: Polygon geometry column created from the input linestrings.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">line_string</span><span class="p">,)</span> <span class="k">if</span> <span class="n">holes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">line_string</span><span class="p">,</span> <span class="n">holes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_MakePolygon&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_MakeValid">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_MakeValid">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_MakeValid</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">keep_collapsed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert an invalid geometry in a geometry column into a valid geometry.</span>

<span class="sd">    :param geometry: Geometry column that contains the invalid geometry.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param keep_collapsed: If True then collapsed geometries are converted to empty geometries, otherwise they will be converted to valid geometries of a lower dimension, if None then the default value of False is used, defaults to None</span>
<span class="sd">    :type keep_collapsed: Optional[Union[ColumnOrName, bool]], optional</span>
<span class="sd">    :return: Geometry column that contains valid versions of the original geometry.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,)</span> <span class="k">if</span> <span class="n">keep_collapsed</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">keep_collapsed</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_MakeValid&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_MaximumInscribedCircle">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_MaximumInscribedCircle">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_MaximumInscribedCircle</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Finds the largest circle that is contained within a geometry, or which does not overlap any lines and points</span>

<span class="sd">    :param geometry:</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Row of center point, nearest point and radius</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_MaximumInscribedCircle&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_MaxDistance">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_MaxDistance">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_MaxDistance</span><span class="p">(</span><span class="n">geom1</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">geom2</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the maximum distance between two furthest points in the geometries</span>

<span class="sd">    :param geom1:</span>
<span class="sd">    :type geom1: ColumnOrName</span>
<span class="sd">    :param geom2:</span>
<span class="sd">    :type geom2: ColumnOrName</span>
<span class="sd">    :return: Maximum distance between the geometries</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_MaxDistance&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">geom1</span><span class="p">,</span> <span class="n">geom2</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_MinimumClearance">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_MinimumClearance">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_MinimumClearance</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the minimum clearance between two vertices</span>

<span class="sd">    :param geometry: Geometry column</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Minimum Clearance between the geometries</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_MinimumClearance&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_MinimumClearanceLine">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_MinimumClearanceLine">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_MinimumClearanceLine</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the minimum clearance Linestring between two vertices</span>

<span class="sd">    :param geometry: Geometry column</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Minimum Clearance Linestring between the geometries</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_MinimumClearanceLine&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_MinimumBoundingCircle">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_MinimumBoundingCircle">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_MinimumBoundingCircle</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">quadrant_segments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate the minimum bounding circle that contains a geometry.</span>

<span class="sd">    :param geometry: Geometry column to generate minimum bounding circles for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param quadrant_segments: Number of quadrant segments to use, if None then use a default value, defaults to None</span>
<span class="sd">    :type quadrant_segments: Optional[Union[ColumnOrName, int]], optional</span>
<span class="sd">    :return: Geometry column that contains the minimum bounding circles.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,)</span> <span class="k">if</span> <span class="n">quadrant_segments</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">quadrant_segments</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_MinimumBoundingCircle&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_MinimumBoundingRadius">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_MinimumBoundingRadius">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_MinimumBoundingRadius</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the minimum bounding radius from the centroid of a geometry that will contain it.</span>

<span class="sd">    :param geometry: Geometry column to generate minimum bounding radii for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Struct column with a center field containing point geometry for the center of geometry and a radius field with a double value for the bounding radius.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_MinimumBoundingRadius&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Multi">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Multi">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Multi</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert the geometry column into a multi-geometry column.</span>

<span class="sd">    :param geometry: Geometry column to convert.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Multi-geometry form of geometry as a geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Multi&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Normalize">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Normalize">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Normalize</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert geometry in a geometry column to a canonical form.</span>

<span class="sd">    :param geometry: Geometry to convert.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Geometry with points ordered in a canonical way as a geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Normalize&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_NPoints">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_NPoints">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_NPoints</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the number of points contained in a geometry.</span>

<span class="sd">    :param geometry: Geometry column to return for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Number of points in a geometry column as an integer column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_NPoints&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_NDims">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_NDims">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_NDims</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the number of dimensions contained in a geometry.</span>

<span class="sd">    :param geometry: Geometry column to return for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Number of dimensions in a geometry column as an integer column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_NDims&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_NumGeometries">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_NumGeometries">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_NumGeometries</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the number of geometries contained in a multi-geometry.</span>

<span class="sd">    :param geometry: Multi-geometry column to return for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Number of geometries contained in a multi-geometry column as an integer column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_NumGeometries&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_NumInteriorRings">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_NumInteriorRings">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_NumInteriorRings</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the number of interior rings contained in a polygon geometry.</span>

<span class="sd">    :param geometry: Polygon geometry column to return for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Number of interior rings polygons contain as an integer column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_NumInteriorRings&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_NumInteriorRing">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_NumInteriorRing">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_NumInteriorRing</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the number of interior rings contained in a polygon geometry.</span>

<span class="sd">    :param geometry: Polygon geometry column to return for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Number of interior rings polygons contain as an integer column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_NumInteriorRing&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_PointN">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_PointN">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_PointN</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the n-th point (starts at 1) for a geometry.</span>

<span class="sd">    :param geometry: Geometry column to get the point from.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param n: Index for the point to return, 1-based, negative values start from the end so -1 is the last point, values that are out of bounds return null.</span>
<span class="sd">    :type n: Union[ColumnOrName, int]</span>
<span class="sd">    :return: n-th point from the geometry as a point geometry column, or null if index is out of bounds.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_PointN&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_PointOnSurface">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_PointOnSurface">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_PointOnSurface</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get a point that is guaranteed to lie on the surface.</span>

<span class="sd">    :param geometry: Geometry column containing the Surface to get a point from.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Point that lies on geometry as a point geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_PointOnSurface&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_ReducePrecision">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_ReducePrecision">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_ReducePrecision</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">precision</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reduce the precision of the coordinates in geometry to a specified number of decimal places.</span>

<span class="sd">    :param geometry: Geometry to reduce the precision of.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param precision: Number of decimal places to reduce the precision to as either an integer or integer column, 0 reduces precision to whole numbers.</span>
<span class="sd">    :type precision: Union[ColumnOrName, int]</span>
<span class="sd">    :return: Geometry with precision reduced to the indicated number of decimal places as a geometry column, empty geometry if an invalid precision is passed.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_ReducePrecision&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">precision</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_RemovePoint">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_RemovePoint">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_RemovePoint</span><span class="p">(</span>
    <span class="n">line_string</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remove the specified point (0-th based) for a linestring geometry column.</span>

<span class="sd">    :param line_string: Linestring geometry column to remove the point from.</span>
<span class="sd">    :type line_string: ColumnOrName</span>
<span class="sd">    :param index: Index for the point to remove as either an integer or an integer column, 0-th based, negative numbers are ignored.</span>
<span class="sd">    :type index: Union[ColumnOrName, int]</span>
<span class="sd">    :return: Linestring geometry column with the specified point removed, or null if the index is out of bounds.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_RemovePoint&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">line_string</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_RemoveRepeatedPoints">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_RemoveRepeatedPoints">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_RemoveRepeatedPoints</span><span class="p">(</span>
    <span class="n">geom</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Removes duplicate coordinates from a geometry, optionally removing those within a specified distance tolerance.</span>

<span class="sd">    @param geom: Geometry with repeated points</span>
<span class="sd">    @type geom: ColumnOrName</span>
<span class="sd">    @param tolerance: Tolerance for removing nearby coordinates</span>
<span class="sd">    @type tolerance: Optional[Union[ColumnOrName, float]]</span>
<span class="sd">    @return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geom</span><span class="p">,)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_RemoveRepeatedPoints&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Reverse">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Reverse">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Reverse</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reverse the points for the geometry.</span>

<span class="sd">    :param geometry: Geometry column to reverse points for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Geometry with points in reverse order compared to the original.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Reverse&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_S2CellIDs">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_S2CellIDs">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_S2CellIDs</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Cover Geometry with S2 Cells and return a List of Long type cell IDs</span>
<span class="sd">    :param geometry: Geometry column to generate cell IDs</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param level: value between 1 and 31, controls the size of the cells used for coverage. With a bigger level, the cells will be smaller, the coverage will be more accurate, but the result size will be exponentially increasing.</span>
<span class="sd">    :type level: int</span>
<span class="sd">    :return: List of cellIDs</span>
<span class="sd">    :rtype: List[long]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_S2CellIDs&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_S2ToGeom">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_S2ToGeom">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_S2ToGeom</span><span class="p">(</span><span class="n">cells</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">list</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a polygon from the S2 cells</span>

<span class="sd">    :param cells: S2 cells</span>
<span class="sd">    :type cells: List[long]</span>
<span class="sd">    :return: the Polygon for all S2 cells</span>
<span class="sd">    :rtype: Geometry</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_S2ToGeom&quot;</span><span class="p">,</span> <span class="n">cells</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_SetPoint">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_SetPoint">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_SetPoint</span><span class="p">(</span>
    <span class="n">line_string</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">point</span><span class="p">:</span> <span class="n">ColumnOrName</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Replace a point in a linestring.</span>

<span class="sd">    :param line_string: Linestring geometry column which contains the point to be replaced.</span>
<span class="sd">    :type line_string: ColumnOrName</span>
<span class="sd">    :param index: Index for the point to be replaced, 0-based, negative values start from the end so -1 is the last point.</span>
<span class="sd">    :type index: Union[ColumnOrName, int]</span>
<span class="sd">    :param point: Point geometry column to be newly set.</span>
<span class="sd">    :type point: ColumnOrName</span>
<span class="sd">    :return: Linestring geometry column with the replaced point, or null if the index is out of bounds.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_SetPoint&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">line_string</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">point</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_SetSRID">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_SetSRID">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_SetSRID</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">srid</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set the SRID for geometry.</span>

<span class="sd">    :param geometry: Geometry column to set SRID for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param srid: SRID to set as either an integer or an integer column.</span>
<span class="sd">    :type srid: Union[ColumnOrName, int]</span>
<span class="sd">    :return: Geometry column with SRID set to srid.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_SetSRID&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">srid</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_Snap">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Snap">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Snap</span><span class="p">(</span>
    <span class="nb">input</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">reference</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">tolerance</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Snaps input Geometry to reference Geometry controlled by distance tolerance.</span>

<span class="sd">    :param input: Geometry</span>
<span class="sd">    :param reference: Geometry to snap to</span>
<span class="sd">    :param tolerance: Distance to control snapping</span>
<span class="sd">    :return: Snapped Geometry</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Snap&quot;</span><span class="p">,</span> <span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_IsPolygonCCW">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_IsPolygonCCW">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_IsPolygonCCW</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if the Polygon or MultiPolygon use a counter-clockwise orientation for exterior ring and clockwise</span>
<span class="sd">    orientation for interior ring.</span>
<span class="sd">    :param geometry: Geometry column to check.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: True if the geometry is empty and False otherwise as a boolean column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_IsPolygonCCW&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_ForcePolygonCCW">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_ForcePolygonCCW">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_ForcePolygonCCW</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a geometry with counter-clockwise oriented exterior ring and clockwise oriented interior rings</span>
<span class="sd">    :param geometry: Geometry column to change orientation</span>
<span class="sd">    :return: counter-clockwise oriented geometry</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_ForcePolygonCCW&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_SRID">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_SRID">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_SRID</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the SRID of geometry.</span>

<span class="sd">    :param geometry: Geometry column to get SRID from.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: SRID of geometry in the geometry column as an integer column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_SRID&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_StartPoint">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_StartPoint">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_StartPoint</span><span class="p">(</span><span class="n">line_string</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the first point from a linestring.</span>

<span class="sd">    :param line_string: Linestring geometry column to get the first points for.</span>
<span class="sd">    :type line_string: ColumnOrName</span>
<span class="sd">    :return: First of the linestring geometry as a point geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_StartPoint&quot;</span><span class="p">,</span> <span class="n">line_string</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_SubDivide">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_SubDivide">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_SubDivide</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">max_vertices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subdivide a geometry into an array of geometries with at maximum number of vertices in each.</span>

<span class="sd">    :param geometry: Geometry column to subdivide.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param max_vertices: Maximum number of vertices to have in each subdivision.</span>
<span class="sd">    :type max_vertices: Union[ColumnOrName, int]</span>
<span class="sd">    :return: Array of geometries that represent the subdivision of the original geometry.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_SubDivide&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">max_vertices</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_SubDivideExplode">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_SubDivideExplode">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_SubDivideExplode</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">max_vertices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Same as ST_SubDivide except also explode the generated array into multiple rows.</span>

<span class="sd">    :param geometry: Geometry column to subdivide.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param max_vertices: Maximum number of vertices to have in each subdivision.</span>
<span class="sd">    :type max_vertices: Union[ColumnOrName, int]</span>
<span class="sd">    :return: Individual geometries exploded from the returned array of ST_SubDivide.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_SubDivideExplode&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">max_vertices</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_Segmentize">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Segmentize">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Segmentize</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">maxSegmentLength</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified geometry/geography having no segment longer than max_segment_length. Length is computed in 2D. Segments are always split into equal-length subsegments.</span>

<span class="sd">    :param geometry: Geometry column to segmentize.</span>
<span class="sd">    :param maxSegmentLength: Maximum segment length</span>
<span class="sd">    :return: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Segmentize&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">maxSegmentLength</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_Simplify">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Simplify">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Simplify</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">distance_tolerance</span><span class="p">:</span> <span class="n">ColumnOrNameOrNumber</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simplify a geometry using Douglas-Peucker algorithm within a specified tolerance while preserving topological relationships.</span>

<span class="sd">    :param geometry: Geometry column to simplify.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param distance_tolerance: Tolerance for merging points together to simplify the geometry as either a number or numeric column.</span>
<span class="sd">    :type distance_tolerance: ColumnOrNameOrNumber</span>
<span class="sd">    :return: Simplified geometry as a geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Simplify&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">distance_tolerance</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_SimplifyPreserveTopology">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_SimplifyPreserveTopology">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_SimplifyPreserveTopology</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">distance_tolerance</span><span class="p">:</span> <span class="n">ColumnOrNameOrNumber</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simplify a geometry within a specified tolerance while preserving topological relationships.</span>

<span class="sd">    :param geometry: Geometry column to simplify.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param distance_tolerance: Tolerance for merging points together to simplify the geometry as either a number or numeric column.</span>
<span class="sd">    :type distance_tolerance: ColumnOrNameOrNumber</span>
<span class="sd">    :return: Simplified geometry as a geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span>
        <span class="s2">&quot;ST_SimplifyPreserveTopology&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">distance_tolerance</span><span class="p">)</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="ST_SimplifyVW">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_SimplifyVW">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_SimplifyVW</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">distance_tolerance</span><span class="p">:</span> <span class="n">ColumnOrNameOrNumber</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simplify a geometry using Visvalingam-Whyatt algorithm within a specified tolerance while preserving topological relationships.</span>

<span class="sd">    :param geometry: Geometry column to simplify.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param distance_tolerance: Tolerance for merging points together to simplify the geometry as either a number or numeric column.</span>
<span class="sd">    :type distance_tolerance: ColumnOrNameOrNumber</span>
<span class="sd">    :return: Simplified geometry as a geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_SimplifyVW&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">distance_tolerance</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_SimplifyPolygonHull">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_SimplifyPolygonHull">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_SimplifyPolygonHull</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">vertexFactor</span><span class="p">:</span> <span class="n">ColumnOrNameOrNumber</span><span class="p">,</span>
    <span class="n">isOuter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simplify a geometry using Visvalingam-Whyatt algorithm within a specified tolerance while preserving topological relationships.</span>

<span class="sd">    :param geometry: Geometry column to simplify.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param vertexFactor: Tolerance for merging points together to simplify the geometry as either a number or numeric column.</span>
<span class="sd">    :type vertexFactor: ColumnOrNameOrNumber</span>
<span class="sd">    :return: Simplified geometry as a geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">vertexFactor</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">isOuter</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">else</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">vertexFactor</span><span class="p">,</span> <span class="n">isOuter</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_SimplifyPolygonHull&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Split">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Split">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Split</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">blade</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Split input geometry by the blade geometry.</span>

<span class="sd">    :param input: One geometry column to use.</span>
<span class="sd">    :type input: ColumnOrName</span>
<span class="sd">    :param blade: Other geometry column to use.</span>
<span class="sd">    :type blase: ColumnOrName</span>
<span class="sd">    :return: Multi-geometry representing the split of input by blade.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Split&quot;</span><span class="p">,</span> <span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">blade</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_SymDifference">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_SymDifference">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_SymDifference</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the symmetric difference of two geometries (the regions that are only in one of them).</span>

<span class="sd">    :param a: One geometry column to use.</span>
<span class="sd">    :type a: ColumnOrName</span>
<span class="sd">    :param b: Other geometry column to use.</span>
<span class="sd">    :type b: ColumnOrName</span>
<span class="sd">    :return: Geometry representing the symmetric difference of a and b as a geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_SymDifference&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_Transform">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Transform">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Transform</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">source_crs</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">target_crs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">disable_error</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a geometry from one coordinate system to another coordinate system.</span>

<span class="sd">    :param geometry: Geometry column to convert.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param source_crs: Original coordinate system for geometry as a string, a string constant must be wrapped as a string literal (using pyspark.sql.functions.lit).</span>
<span class="sd">    :type source_crs: ColumnOrName</span>
<span class="sd">    :param target_crs: Coordinate system geometry will be converted to as a string, a string constant must be wrapped as a string literal (using pyspark.sql.functions.lit).</span>
<span class="sd">    :type target_crs: ColumnOrName</span>
<span class="sd">    :param disable_error: Whether to disable the error &quot;Bursa wolf parameters required&quot;, defaults to None</span>
<span class="sd">    :type disable_error: Optional[Union[ColumnOrName, bool]], optional</span>
<span class="sd">    :return: Geometry converted to the target coordinate system as an</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">disable_error</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">source_crs</span><span class="p">,</span> <span class="n">target_crs</span><span class="p">)</span>

        <span class="c1"># When 2 arguments are passed to the function.</span>
        <span class="c1"># From python&#39;s perspective ST_Transform(geometry, source_crs) is provided</span>
        <span class="c1"># that&#39;s why have to check if the target_crs is empty.</span>
        <span class="c1"># the source_crs acts as target_crs when calling the function</span>
        <span class="k">if</span> <span class="n">target_crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">source_crs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">source_crs</span><span class="p">,</span> <span class="n">target_crs</span><span class="p">,</span> <span class="n">disable_error</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Transform&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_TriangulatePolygon">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_TriangulatePolygon">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_TriangulatePolygon</span><span class="p">(</span><span class="n">geom</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes the constrained Delaunay triangulation of polygons. Holes and Multipolygons are supported.</span>

<span class="sd">    :param geom: (Multi)Polygon to be triangulated.</span>
<span class="sd">    :type geom: ColumnOrName</span>
<span class="sd">    :return: Triangulated Polygon as GeometryCollection of Polygons</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_TriangulatePolygon&quot;</span><span class="p">,</span> <span class="n">geom</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_UnaryUnion">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_UnaryUnion">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_UnaryUnion</span><span class="p">(</span><span class="n">geom</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the unary union of a geometry</span>

<span class="sd">    :param geom: Geometry to do union</span>
<span class="sd">    :type geom: ColumnOrName</span>
<span class="sd">    :return: Geometry representing the unary union of geom as a geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_UnaryUnion&quot;</span><span class="p">,</span> <span class="n">geom</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Union">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Union">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Union</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the union of two geometries.</span>

<span class="sd">    :param a: One geometry column to use.</span>
<span class="sd">    :type a: ColumnOrName</span>
<span class="sd">    :param b: Other geometry column to use.</span>
<span class="sd">    :type b: ColumnOrName</span>
<span class="sd">    :return: Geometry representing the union of a and b as a geometry column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Union&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_X">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_X">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_X</span><span class="p">(</span><span class="n">point</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the X coordinate of a point geometry.</span>

<span class="sd">    :param point: Point geometry column to get the coordinate for.</span>
<span class="sd">    :type point: ColumnOrName</span>
<span class="sd">    :return: X coordinate of the point geometry as a double column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_X&quot;</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_XMax">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_XMax">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_XMax</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the maximum X coordinate for a geometry.</span>

<span class="sd">    :param geometry: Geometry column to get maximum X coordinate for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Maximum X coordinate for the geometry as a double column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_XMax&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_XMin">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_XMin">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_XMin</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the minimum X coordinate for a geometry.</span>

<span class="sd">    :param geometry: Geometry column to get minimum X coordinate for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Minimum X coordinate for the geometry as a double column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_XMin&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Y">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Y">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Y</span><span class="p">(</span><span class="n">point</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the Y coordinate of a point geometry.</span>

<span class="sd">    :param point: Point geometry column to return the Y coordinate for.</span>
<span class="sd">    :type point: ColumnOrName</span>
<span class="sd">    :return: Y coordinate of the point geometry column as a double column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Y&quot;</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_YMax">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_YMax">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_YMax</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the maximum Y coordinate for a geometry.</span>

<span class="sd">    :param geometry: Geometry column to get the maximum Y coordinate for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Maximum Y coordinate for the geometry as a double column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_YMax&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_YMin">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_YMin">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_YMin</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the minimum Y coordinate for a geometry.</span>

<span class="sd">    :param geometry: Geometry column to get the minimum Y coordinate for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Minimum Y coordinate for the geometry as a double column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_YMin&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Z">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Z">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Z</span><span class="p">(</span><span class="n">point</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the Z coordinate of a point geometry.</span>

<span class="sd">    :param point: Point geometry column to get the Z coordinate from.</span>
<span class="sd">    :type point: ColumnOrName</span>
<span class="sd">    :return: Z coordinate for the point geometry as a double column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Z&quot;</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Zmflag">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Zmflag">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Zmflag</span><span class="p">(</span><span class="n">geom</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the code indicating the ZM coordinate dimension of a geometry</span>
<span class="sd">        2D = 0, 3D-M = 1, 3D-Z = 2, 4D = 3</span>

<span class="sd">    :param geom: Geometry column</span>
<span class="sd">    :type geom: ColumnOrName</span>
<span class="sd">    :return: Code for coordinate dimension of the geometry as an integer column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Zmflag&quot;</span><span class="p">,</span> <span class="n">geom</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_ZMax">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_ZMax">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_ZMax</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the maximum Z coordinate of a geometry.</span>

<span class="sd">    :param geometry: Geometry column to get the maximum Z coordinate from.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Maximum Z coordinate for the geometry as a double column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_ZMax&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_ZMin">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_ZMin">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_ZMin</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the minimum Z coordinate of a geometry.</span>

<span class="sd">    :param geometry: Geometry column to get the minimum Z coordinate from.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Minimum Z coordinate for the geometry as a double column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_ZMin&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_NumPoints">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_NumPoints">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_NumPoints</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the number of points in a LineString</span>
<span class="sd">    :param geometry: Geometry column to get number of points from.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Number of points in a LineString as an integer column</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_NumPoints&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Force3D">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Force3D">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Force3D</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">zValue</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a geometry with a 3D coordinate of value &#39;zValue&#39; forced upon it. No change happens if the geometry is already 3D</span>
<span class="sd">    :param zValue: Optional value of z coordinate to be potentially added, default value is 0.0</span>
<span class="sd">    :param geometry: Geometry column to make 3D</span>
<span class="sd">    :return: 3D geometry with either already present z coordinate if any, or zcoordinate with given zValue</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">zValue</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Force3D&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Force3DM">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Force3DM">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Force3DM</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">mValue</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a geometry with a 3D coordinate of value &#39;mValue&#39; forced upon it. No change happens if the geometry is already 3D</span>
<span class="sd">    :param mValue: Optional value of m coordinate to be potentially added, default value is 0.0</span>
<span class="sd">    :param geometry: Geometry column to make 3D</span>
<span class="sd">    :return: 3D geometry with either already present m coordinate if any, or m coordinate with given mValue</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">mValue</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Force3DM&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Force3DZ">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Force3DZ">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Force3DZ</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">zValue</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a geometry with a 3D coordinate of value &#39;zValue&#39; forced upon it. No change happens if the geometry is already 3D</span>
<span class="sd">    :param zValue: Optional value of z coordinate to be potentially added, default value is 0.0</span>
<span class="sd">    :param geometry: Geometry column to make 3D</span>
<span class="sd">    :return: 3D geometry with either already present z coordinate if any, or zcoordinate with given zValue</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">zValue</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Force3DZ&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Force4D">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Force4D">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Force4D</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">zValue</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">mValue</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a geometry with a 4D coordinate of value &#39;zValue&#39; and mValue forced upon it. No change happens if the</span>
<span class="sd">    geometry is already 4D, if geometry either has z or m, it will not change the existing z or m value.</span>

<span class="sd">    :param zValue: Optional value of z coordinate to be potentially added, default value is 0.0</span>
<span class="sd">    :param geometry: Geometry column to make 4D</span>
<span class="sd">    :return: 4D geometry with either already 4D geom or z and m component provided by zValue and mValue respectively</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">zValue</span><span class="p">,</span> <span class="n">mValue</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Force4D&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_ForceCollection">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_ForceCollection">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_ForceCollection</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a geometry to a geometry collection</span>

<span class="sd">    :param geometry: Geometry column to change orientation</span>
<span class="sd">    :return: a Geometry Collection</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_ForceCollection&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_ForcePolygonCW">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_ForcePolygonCW">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_ForcePolygonCW</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns</span>
<span class="sd">    :param geometry: Geometry column to change orientation</span>
<span class="sd">    :return: Clockwise oriented geometry</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_ForcePolygonCW&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_ForceRHR">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_ForceRHR">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_ForceRHR</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns</span>
<span class="sd">    :param geometry: Geometry column to change orientation</span>
<span class="sd">    :return: Clockwise oriented geometry</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_ForceRHR&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_NRings">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_NRings">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_NRings</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the total number of rings in a Polygon or MultiPolygon. Compared to ST_NumInteriorRings, ST_NRings takes exterior rings into account as well.</span>
<span class="sd">    :param geometry: Geometry column to calculate rings for</span>
<span class="sd">    :return: Number of exterior rings + interior rings (if any) for the given Polygon or MultiPolygon</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_NRings&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Translate">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Translate">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Translate</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">deltaX</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">deltaY</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">deltaZ</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the geometry with x, y and z (if present) coordinates offset by given deltaX, deltaY, and deltaZ values.</span>
<span class="sd">    :param geometry: Geometry column whose coordinates are to be translated.</span>
<span class="sd">    :param deltaX: value by which to offset X coordinate.</span>
<span class="sd">    :param deltaY: value by which to offset Y coordinate.</span>
<span class="sd">    :param deltaZ: value by which to offset Z coordinate (if present).</span>
<span class="sd">    :return: The input geometry with its coordinates translated.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">deltaX</span><span class="p">,</span> <span class="n">deltaY</span><span class="p">,</span> <span class="n">deltaZ</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Translate&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_VoronoiPolygons">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_VoronoiPolygons">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_VoronoiPolygons</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">tolerance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">extendTo</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ST_VoronoiPolygons computes a two-dimensional Voronoi diagram from the vertices of the supplied geometry.</span>
<span class="sd">    The result is a GeometryCollection of Polygons that covers an envelope larger than the extent of the input vertices.</span>
<span class="sd">    Returns null if input geometry is null. Returns an empty geometry collection if the input geometry contains only one vertex. Returns an empty geometry collection if the extend_to envelope has zero area.</span>
<span class="sd">    :param geometry: Geometry column whose coordinates are to be built from.</span>
<span class="sd">    :param tolerance: The distance within which vertices will be considered equivalent.</span>
<span class="sd">    Robustness of the algorithm can be improved by supplying a nonzero tolerance distance. (default = 0.0)</span>
<span class="sd">    :param extendTo: If a geometry is supplied as the &quot;extend_to&quot; parameter, the diagram will be extended to cover the envelope of the &quot;extend_to&quot; geometry, unless that envelope is smaller than the default envelope</span>
<span class="sd">    (default = NULL, default envelope is boundingbox of input geometry extended by about 50% in each direction).</span>
<span class="sd">    :return: The two-dimensional Voronoi diagram geometry.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">extendTo</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_VoronoiPolygons&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_FrechetDistance">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_FrechetDistance">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_FrechetDistance</span><span class="p">(</span><span class="n">g1</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">g2</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes discrete frechet distance between the two geometries.</span>
<span class="sd">    If any of the geometry is empty, ST_FrechetDistance returns 0</span>
<span class="sd">    :param g1:</span>
<span class="sd">    :param g2:</span>
<span class="sd">    :return: Computed Discrete Frechet Distance between g1 and g2</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_FrechetDistance&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Affine">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Affine">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Affine</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">d</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">e</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">xOff</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">yOff</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">c</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">f</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">g</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">h</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">i</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">zOff</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a 3D/2D affine transformation to the given geometry</span>
<span class="sd">    x = a * x + b * y + c * z + xOff | x = a * x + b * y + xOff</span>
<span class="sd">    y = d * x + e * y + f * z + yOff | y = d * x + e * y + yOff</span>
<span class="sd">    z = g * x + h * y + i * z + zOff</span>
<span class="sd">    :param geometry: Geometry to apply affine transformation to</span>
<span class="sd">    :param a:</span>
<span class="sd">    :param b:</span>
<span class="sd">    :param c: Default 0.0</span>
<span class="sd">    :param d:</span>
<span class="sd">    :param e:</span>
<span class="sd">    :param f: Default 0.0</span>
<span class="sd">    :param g: Default 0.0</span>
<span class="sd">    :param h: Default 0.0</span>
<span class="sd">    :param i: Default 0.0</span>
<span class="sd">    :param xOff:</span>
<span class="sd">    :param yOff:</span>
<span class="sd">    :param zOff: Default 0.0</span>
<span class="sd">    :return: Geometry with affine transformation applied</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">xOff</span><span class="p">,</span> <span class="n">yOff</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">zOff</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">xOff</span><span class="p">,</span> <span class="n">yOff</span><span class="p">,</span> <span class="n">zOff</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Affine&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_BoundingDiagonal">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_BoundingDiagonal">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_BoundingDiagonal</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a LineString with the min/max values of each dimension of the bounding box of the given geometry as its</span>
<span class="sd">    start/end coordinates.</span>
<span class="sd">    :param geometry: Geometry to return bounding diagonal of.</span>
<span class="sd">    :return: LineString spanning min and max values of each dimension of the given geometry</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_BoundingDiagonal&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Angle">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Angle">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Angle</span><span class="p">(</span>
    <span class="n">g1</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">g2</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">g3</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">g4</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the computed angle between vectors formed by given geometries in radian. Range of result is between 0 and 2 * pi.</span>

<span class="sd">    3 Variants:</span>

<span class="sd">    - Angle(Point1, Point2, Point3, Point4)</span>
<span class="sd">        Computes angle formed by vectors formed by Point1-Point2 and Point3-Point4</span>
<span class="sd">    - Angle(Point1, Point2, Point3)</span>
<span class="sd">        Computes angle formed by angle Point1-Point2-Point3</span>
<span class="sd">    - Angle(Line1, Line2)</span>
<span class="sd">        Computes angle between vectors formed by S1-E1 and S2-E2, where S and E are start and endpoints.</span>

<span class="sd">    :param g1: Point or Line</span>
<span class="sd">    :param g2: Point or Line</span>
<span class="sd">    :param g3: Point or None</span>
<span class="sd">    :param g4: Point or None</span>
<span class="sd">    :return: Returns the computed angle</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">g3</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">g4</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">g3</span><span class="p">,</span> <span class="n">g4</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">g3</span><span class="p">)</span>
    <span class="c1"># args = (g1, g2, g3, g4)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Angle&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Degrees">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Degrees">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Degrees</span><span class="p">(</span><span class="n">angleInRadian</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a given angle from radian to degrees</span>
<span class="sd">    :param angleInRadian: Angle in Radian</span>
<span class="sd">    :return: Angle in Degrees</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Degrees&quot;</span><span class="p">,</span> <span class="n">angleInRadian</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_DelaunayTriangles">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_DelaunayTriangles">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_DelaunayTriangles</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">tolerance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">flag</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Delaunay Triangles of the vertices of the input geometry.</span>

<span class="sd">    :param geometry: Input geometry</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param tolerance:</span>
<span class="sd">    :type tolerance: ColumnOrName or float</span>
<span class="sd">    :param flag: Selects the output type</span>
<span class="sd">    :type flag: ColumnOrName or int</span>
<span class="sd">    :return: Delaunay triangles of the input geometry</span>
<span class="sd">    :rtype: ColumnOrName</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">flag</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">geometry</span>
    <span class="k">elif</span> <span class="n">flag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_DelaunayTriangles&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_HausdorffDistance">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_HausdorffDistance">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_HausdorffDistance</span><span class="p">(</span>
    <span class="n">g1</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">g2</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">densityFrac</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns discretized (and hence approximate) hausdorff distance between two given geometries.</span>
<span class="sd">    Optionally, a distance fraction can also be provided which decreases the gap between actual and discretized hausforff distance</span>
<span class="sd">    :param g1:</span>
<span class="sd">    :param g2:</span>
<span class="sd">    :param densityFrac: Optional</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">densityFrac</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_HausdorffDistance&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_CoordDim">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_CoordDim">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_CoordDim</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the number of dimensions contained in a coordinate</span>

<span class="sd">    :param geometry: Geometry column to return for.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: Number of dimensions in a coordinate column as an integer column.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_CoordDim&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_IsCollection">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_IsCollection">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_IsCollection</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if the geometry is of GeometryCollection type.</span>

<span class="sd">    :param geometry: Column for geometry collection</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :return: True if geometry is a collection of geometries.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_IsCollection&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_Scale">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Scale">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Scale</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">scaleX</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrNameOrNumber</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">scaleY</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrNameOrNumber</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Scale geometry with X and Y axis.</span>

<span class="sd">    @param geometry:</span>
<span class="sd">    @param scaleX:</span>
<span class="sd">    @param scaleY:</span>
<span class="sd">    @return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Scale&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">scaleX</span><span class="p">,</span> <span class="n">scaleY</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_ScaleGeom">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_ScaleGeom">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_ScaleGeom</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">factor</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">origin</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Scale geometry with the corodinates of factor geometry</span>

<span class="sd">    @param geometry:</span>
<span class="sd">    @param factor:</span>
<span class="sd">    @param origin:</span>
<span class="sd">    @return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_ScaleGeom&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_RotateX">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_RotateX">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_RotateX</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">angle</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns geometry rotated by the given angle in X axis</span>

<span class="sd">    @param geometry: Geometry column or name</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    @param angle: Rotation angle in radians</span>
<span class="sd">    :type angle: float</span>
<span class="sd">    @return: X-axis rotated geometry</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_RotateX&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_RotateY">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_RotateY">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_RotateY</span><span class="p">(</span><span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">angle</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns geometry rotated by the given angle in Y axis</span>

<span class="sd">    @param geometry: Geometry column or name</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    @param angle: Rotation angle in radians</span>
<span class="sd">    :type angle: float</span>
<span class="sd">    @return: Y-axis rotated geometry</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_RotateY&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_Rotate">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_Rotate">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_Rotate</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">angle</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">originX</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">originY</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">pointOrigin</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a counter-clockwise rotated geometry along the specified origin.</span>

<span class="sd">    :param geometry: Geometry column or name.</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    :param angle: Rotation angle in radians.</span>
<span class="sd">    :type angle: Union[ColumnOrName, float]</span>
<span class="sd">    :param originX: Optional x-coordinate of the origin.</span>
<span class="sd">    :type originX: Union[ColumnOrName, float]</span>
<span class="sd">    :param originY: Optional y-coordinate of the origin.</span>
<span class="sd">    :type originY: Union[ColumnOrName, float]</span>
<span class="sd">    :param pointOrigin: Optional origin point for rotation.</span>
<span class="sd">    :type pointOrigin: ColumnOrName</span>
<span class="sd">    :return: Returns the rotated geometry.</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">pointOrigin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">pointOrigin</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">originX</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">originY</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">originX</span><span class="p">,</span> <span class="n">originY</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_Rotate&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_InterpolatePoint">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_InterpolatePoint">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_InterpolatePoint</span><span class="p">(</span><span class="n">geom1</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span> <span class="n">geom2</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the interpolated Measure value at the point on the given linestring M that is closest to the given point.</span>

<span class="sd">    :param geom1: LineString M Geometry column or name.</span>
<span class="sd">    :type geom1: ColumnOrName</span>
<span class="sd">    :param geom2: Point Geometry column or name.</span>
<span class="sd">    :type geom2: ColumnOrName</span>
<span class="sd">    :rtype: Column</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">geom1</span><span class="p">,</span> <span class="n">geom2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_InterpolatePoint&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>



<div class="viewcode-block" id="ST_DBSCAN">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_DBSCAN">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_DBSCAN</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">min_pts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">use_spheroid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform DBSCAN clustering on the given geometry column.</span>

<span class="sd">    @param geometry: Geometry column or name</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    @param epsilon: the distance between two points to be considered neighbors</span>
<span class="sd">    :type epsilon: ColumnOrName</span>
<span class="sd">    @param min_pts: the number of neighbors a point should have to form a cluster</span>
<span class="sd">    :type min_pts: ColumnOrName</span>
<span class="sd">    @param use_spheroid: whether to use spheroid for distance calculation</span>
<span class="sd">    :type use_spheroid: ColumnOrName</span>
<span class="sd">    @return: A struct indicating the cluster to which the point belongs and whether it is a core point</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">epsilon</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="n">lit</span><span class="p">(</span><span class="n">epsilon</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">min_pts</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">min_pts</span> <span class="o">=</span> <span class="n">lit</span><span class="p">(</span><span class="n">min_pts</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">use_spheroid</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">use_spheroid</span> <span class="o">=</span> <span class="n">lit</span><span class="p">(</span><span class="n">use_spheroid</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_DBSCAN&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">min_pts</span><span class="p">,</span> <span class="n">use_spheroid</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_LocalOutlierFactor">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_LocalOutlierFactor">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_LocalOutlierFactor</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">use_spheroid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the local outlier factor on the given geometry column.</span>

<span class="sd">    @param geometry: Geometry column or name</span>
<span class="sd">    :type geometry: ColumnOrName</span>
<span class="sd">    @param k: the number of neighbors to use for LOF calculation</span>
<span class="sd">    :type k: ColumnOrName</span>
<span class="sd">    @param use_spheroid: whether to use spheroid for distance calculation</span>
<span class="sd">    :type use_spheroid: ColumnOrName</span>
<span class="sd">    @return: A Double indicating the local outlier factor of the point</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">lit</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">use_spheroid</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">use_spheroid</span> <span class="o">=</span> <span class="n">lit</span><span class="p">(</span><span class="n">use_spheroid</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_LocalOutlierFactor&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">use_spheroid</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_GLocal">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_GLocal">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_GLocal</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">weights</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">star</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate Getis Ord Gi(*) statistics on the given column.</span>

<span class="sd">    @param x: The variable we want to compute Gi statistics for</span>
<span class="sd">    :type x: ColumnOrName</span>
<span class="sd">    @param weights: the weights array containing the neighbors, their weights, and their values of x</span>
<span class="sd">    :type weights: ColumnOrName</span>
<span class="sd">    @param star: whether to use the focal observation in the calculations</span>
<span class="sd">    :type star: ColumnOrName</span>
<span class="sd">    @return: A struct containing the Gi statistics including a p value</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">star</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">star</span> <span class="o">=</span> <span class="n">lit</span><span class="p">(</span><span class="n">star</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span><span class="s2">&quot;ST_GLocal&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">star</span><span class="p">))</span></div>



<div class="viewcode-block" id="ST_BinaryDistanceBandColumn">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_BinaryDistanceBandColumn">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_BinaryDistanceBandColumn</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">threshold</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">include_zero_distance_neighbors</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_self</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">use_spheroid</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">attributes</span><span class="p">:</span> <span class="n">ColumnOrName</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates a weights column containing the other records within the threshold and their weight.</span>

<span class="sd">    Weights will always be 1.0.</span>


<span class="sd">    @param geometry: name of the geometry column</span>
<span class="sd">    @param threshold: Distance threshold for considering neighbors</span>
<span class="sd">    @param include_zero_distance_neighbors: whether to include neighbors that are 0 distance.</span>
<span class="sd">    @param include_self: whether to include self in the list of neighbors</span>
<span class="sd">    @param use_spheroid: whether to use a cartesian or spheroidal distance calculation. Default is false</span>
<span class="sd">    @param attributes: the attributes to save in the neighbor column.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">include_zero_distance_neighbors</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">include_zero_distance_neighbors</span> <span class="o">=</span> <span class="n">lit</span><span class="p">(</span><span class="n">include_zero_distance_neighbors</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">include_self</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">include_self</span> <span class="o">=</span> <span class="n">lit</span><span class="p">(</span><span class="n">include_self</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">use_spheroid</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">use_spheroid</span> <span class="o">=</span> <span class="n">lit</span><span class="p">(</span><span class="n">use_spheroid</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span>
        <span class="s2">&quot;ST_BinaryDistanceBandColumn&quot;</span><span class="p">,</span>
        <span class="p">(</span>
            <span class="n">geometry</span><span class="p">,</span>
            <span class="n">threshold</span><span class="p">,</span>
            <span class="n">include_zero_distance_neighbors</span><span class="p">,</span>
            <span class="n">include_self</span><span class="p">,</span>
            <span class="n">use_spheroid</span><span class="p">,</span>
            <span class="n">attributes</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="ST_WeightedDistanceBandColumn">
<a class="viewcode-back" href="../../../../sedona.spark.sql.html#sedona.spark.sql.st_functions.ST_WeightedDistanceBandColumn">[docs]</a>
<span class="nd">@validate_argument_types</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ST_WeightedDistanceBandColumn</span><span class="p">(</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">threshold</span><span class="p">:</span> <span class="n">ColumnOrName</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="n">include_zero_distance_neighbors</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_self</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">self_weight</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">use_spheroid</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ColumnOrName</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">attributes</span><span class="p">:</span> <span class="n">ColumnOrName</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates a weights column containing the other records within the threshold and their weight.</span>

<span class="sd">    Weights will be distance^alpha.</span>

<span class="sd">    :param geometry: name of the geometry column</span>
<span class="sd">    :param threshold: Distance threshold for considering neighbors</span>
<span class="sd">    :param alpha: alpha to use for inverse distance weights. Computation is dist^alpha. Default is -1.0</span>
<span class="sd">    :param include_zero_distance_neighbors: whether to include neighbors that are 0 distance. If 0 distance neighbors are</span>
<span class="sd">        included, values are infinity as per the floating point spec (divide by 0)</span>
<span class="sd">    :param include_self: whether to include self in the list of neighbors</span>
<span class="sd">    :param self_weight: the value to use for the self weight. Default is 1.0</span>
<span class="sd">    :param use_spheroid: whether to use a cartesian or spheroidal distance calculation. Default is false</span>
<span class="sd">    :param attributes: the attributes to save in the neighbor column.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">lit</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">include_zero_distance_neighbors</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">include_zero_distance_neighbors</span> <span class="o">=</span> <span class="n">lit</span><span class="p">(</span><span class="n">include_zero_distance_neighbors</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">include_self</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">include_self</span> <span class="o">=</span> <span class="n">lit</span><span class="p">(</span><span class="n">include_self</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">self_weight</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">self_weight</span> <span class="o">=</span> <span class="n">lit</span><span class="p">(</span><span class="n">self_weight</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">use_spheroid</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">use_spheroid</span> <span class="o">=</span> <span class="n">lit</span><span class="p">(</span><span class="n">use_spheroid</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_call_st_function</span><span class="p">(</span>
        <span class="s2">&quot;ST_WeightedDistanceBandColumn&quot;</span><span class="p">,</span>
        <span class="p">(</span>
            <span class="n">geometry</span><span class="p">,</span>
            <span class="n">threshold</span><span class="p">,</span>
            <span class="n">alpha</span><span class="p">,</span>
            <span class="n">include_zero_distance_neighbors</span><span class="p">,</span>
            <span class="n">include_self</span><span class="p">,</span>
            <span class="n">self_weight</span><span class="p">,</span>
            <span class="n">use_spheroid</span><span class="p">,</span>
            <span class="n">attributes</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">)</span></div>



<span class="c1"># Automatically populate __all__</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">name</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmembers</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;GeometryType&quot;</span>
<span class="p">]</span>
</pre></div>

           </div>
          </div>
    </div>

          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Apache Software Foundation.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>