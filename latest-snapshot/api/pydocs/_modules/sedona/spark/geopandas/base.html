

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sedona.spark.geopandas.base &mdash; Apache Sedona Python Documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/custom.css?v=08a75d8b" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=908dc885"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
     
    <!-- Google Fonts for Apache Sedona styling -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Additional meta tags for better rendering -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1565c0">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #ff5722" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            Apache Sedona Python
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules.html">sedona</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.html">sedona package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.html#subpackages">Subpackages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.core.html">sedona.core package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.flink.html">sedona.flink package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.geoarrow.html">sedona.geoarrow package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.maps.html">sedona.maps package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.raster.html">sedona.raster package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.raster_utils.html">sedona.raster_utils package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.register.html">sedona.register package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.html">sedona.spark package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.sql.html">sedona.sql package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.stac.html">sedona.stac package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.stats.html">sedona.stats package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.utils.html">sedona.utils package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.html#module-sedona.exceptions">sedona.exceptions module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.html#sedona.exceptions.InvalidParametersException"><code class="docutils literal notranslate"><span class="pre">InvalidParametersException</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.html#module-sedona.version">sedona.version module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.html#module-sedona">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../sedona.flink.html">sedona.flink package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.flink.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.flink.html#module-sedona.flink.context">sedona.flink.context module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.flink.html#sedona.flink.context.SedonaContext"><code class="docutils literal notranslate"><span class="pre">SedonaContext</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.flink.html#sedona.flink.context.SedonaContext.create"><code class="docutils literal notranslate"><span class="pre">SedonaContext.create()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.flink.html#module-sedona.flink">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../sedona.spark.html">sedona.spark package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.spark.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.core.html">sedona.spark.core package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.core.html#subpackages">Subpackages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.core.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.core.html#module-sedona.spark.core.utils">sedona.spark.core.utils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.core.html#module-sedona.spark.core">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.geoarrow.html">sedona.spark.geoarrow package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geoarrow.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geoarrow.html#module-sedona.spark.geoarrow.geoarrow">sedona.spark.geoarrow.geoarrow module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geoarrow.html#module-sedona.spark.geoarrow">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.geopandas.html">sedona.spark.geopandas package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#subpackages">Subpackages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#module-sedona.spark.geopandas.base">sedona.spark.geopandas.base module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#module-sedona.spark.geopandas.geodataframe">sedona.spark.geopandas.geodataframe module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#module-sedona.spark.geopandas.geoseries">sedona.spark.geopandas.geoseries module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#module-sedona.spark.geopandas.io">sedona.spark.geopandas.io module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#module-sedona.spark.geopandas.sindex">sedona.spark.geopandas.sindex module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#module-sedona.spark.geopandas">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.maps.html">sedona.spark.maps package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.maps.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.maps.html#module-sedona.spark.maps.SedonaKepler">sedona.spark.maps.SedonaKepler module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.maps.html#module-sedona.spark.maps.SedonaMapUtils">sedona.spark.maps.SedonaMapUtils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.maps.html#module-sedona.spark.maps.SedonaPyDeck">sedona.spark.maps.SedonaPyDeck module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.maps.html#module-sedona.spark.maps">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.raster.html">sedona.spark.raster package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.raster.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.raster.html#module-sedona.spark.raster.awt_raster">sedona.spark.raster.awt_raster module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.raster.html#module-sedona.spark.raster.data_buffer">sedona.spark.raster.data_buffer module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.raster.html#module-sedona.spark.raster.meta">sedona.spark.raster.meta module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.raster.html#module-sedona.spark.raster.raster_serde">sedona.spark.raster.raster_serde module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.raster.html#module-sedona.spark.raster.sample_model">sedona.spark.raster.sample_model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.raster.html#module-sedona.spark.raster.sedona_raster">sedona.spark.raster.sedona_raster module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.raster.html#module-sedona.spark.raster">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.raster_utils.html">sedona.spark.raster_utils package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.raster_utils.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.raster_utils.html#module-sedona.spark.raster_utils.SedonaUtils">sedona.spark.raster_utils.SedonaUtils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.raster_utils.html#module-sedona.spark.raster_utils">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.register.html">sedona.spark.register package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.register.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.register.html#module-sedona.spark.register.geo_registrator">sedona.spark.register.geo_registrator module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.register.html#module-sedona.spark.register.java_libs">sedona.spark.register.java_libs module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.register.html#module-sedona.spark.register">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.sql.html">sedona.spark.sql package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.sql.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.sql.html#sedona-spark-sql-connect-module">sedona.spark.sql.connect module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.sql.html#module-sedona.spark.sql.dataframe_api">sedona.spark.sql.dataframe_api module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.sql.html#module-sedona.spark.sql.exceptions">sedona.spark.sql.exceptions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.sql.html#module-sedona.spark.sql.functions">sedona.spark.sql.functions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.sql.html#module-sedona.spark.sql.st_aggregates">sedona.spark.sql.st_aggregates module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.sql.html#module-sedona.spark.sql.st_constructors">sedona.spark.sql.st_constructors module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.sql.html#module-sedona.spark.sql.st_functions">sedona.spark.sql.st_functions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.sql.html#module-sedona.spark.sql.st_predicates">sedona.spark.sql.st_predicates module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.sql.html#module-sedona.spark.sql.types">sedona.spark.sql.types module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.sql.html#module-sedona.spark.sql">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.stac.html">sedona.spark.stac package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.stac.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.stac.html#module-sedona.spark.stac.client">sedona.spark.stac.client module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.stac.html#module-sedona.spark.stac.collection_client">sedona.spark.stac.collection_client module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.stac.html#module-sedona.spark.stac">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.stats.html">sedona.spark.stats package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.stats.html#subpackages">Subpackages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.stats.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.stats.html#module-sedona.spark.stats.weighting">sedona.spark.stats.weighting module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.stats.html#module-sedona.spark.stats">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.utils.html">sedona.spark.utils package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.abstract_parser">sedona.spark.utils.abstract_parser module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.adapter">sedona.spark.utils.adapter module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.binary_parser">sedona.spark.utils.binary_parser module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.decorators">sedona.spark.utils.decorators module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.geometry_adapter">sedona.spark.utils.geometry_adapter module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.geometry_serde">sedona.spark.utils.geometry_serde module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.geometry_serde_general">sedona.spark.utils.geometry_serde_general module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.geomserde_speedup">sedona.spark.utils.geomserde_speedup module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.jvm">sedona.spark.utils.jvm module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.meta">sedona.spark.utils.meta module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.prep">sedona.spark.utils.prep module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.serde">sedona.spark.utils.serde module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.spatial_rdd_parser">sedona.spark.utils.spatial_rdd_parser module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.structured_adapter">sedona.spark.utils.structured_adapter module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils.types">sedona.spark.utils.types module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.utils.html#module-sedona.spark.utils">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.spark.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.spark.html#module-sedona.spark.SedonaContext">sedona.spark.SedonaContext module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.html#sedona.spark.SedonaContext.SedonaContext"><code class="docutils literal notranslate"><span class="pre">SedonaContext</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.html#sedona.spark.SedonaContext.SedonaContext.__init__"><code class="docutils literal notranslate"><span class="pre">SedonaContext.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.html#sedona.spark.SedonaContext.SedonaContext.builder"><code class="docutils literal notranslate"><span class="pre">SedonaContext.builder()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.html#sedona.spark.SedonaContext.SedonaContext.create"><code class="docutils literal notranslate"><span class="pre">SedonaContext.create()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.spark.html#module-sedona.spark">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../sedona.spark.geopandas.html">sedona.spark.geopandas package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.geopandas.tools.html">sedona.spark.geopandas.tools package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.tools.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.tools.html#module-sedona.spark.geopandas.tools.sjoin">sedona.spark.geopandas.tools.sjoin module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.tools.html#module-sedona.spark.geopandas.tools">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#module-sedona.spark.geopandas.base">sedona.spark.geopandas.base module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame"><code class="docutils literal notranslate"><span class="pre">GeoFrame</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.area"><code class="docutils literal notranslate"><span class="pre">GeoFrame.area</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.boundary"><code class="docutils literal notranslate"><span class="pre">GeoFrame.boundary</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.bounds"><code class="docutils literal notranslate"><span class="pre">GeoFrame.bounds</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.buffer"><code class="docutils literal notranslate"><span class="pre">GeoFrame.buffer()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.centroid"><code class="docutils literal notranslate"><span class="pre">GeoFrame.centroid</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.contains"><code class="docutils literal notranslate"><span class="pre">GeoFrame.contains()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.contains_properly"><code class="docutils literal notranslate"><span class="pre">GeoFrame.contains_properly()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.copy"><code class="docutils literal notranslate"><span class="pre">GeoFrame.copy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.covered_by"><code class="docutils literal notranslate"><span class="pre">GeoFrame.covered_by()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.covers"><code class="docutils literal notranslate"><span class="pre">GeoFrame.covers()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.crosses"><code class="docutils literal notranslate"><span class="pre">GeoFrame.crosses()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.difference"><code class="docutils literal notranslate"><span class="pre">GeoFrame.difference()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.distance"><code class="docutils literal notranslate"><span class="pre">GeoFrame.distance()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.dwithin"><code class="docutils literal notranslate"><span class="pre">GeoFrame.dwithin()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.envelope"><code class="docutils literal notranslate"><span class="pre">GeoFrame.envelope</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.geom_type"><code class="docutils literal notranslate"><span class="pre">GeoFrame.geom_type</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.get_geometry"><code class="docutils literal notranslate"><span class="pre">GeoFrame.get_geometry()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.has_sindex"><code class="docutils literal notranslate"><span class="pre">GeoFrame.has_sindex</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.has_z"><code class="docutils literal notranslate"><span class="pre">GeoFrame.has_z</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.intersection"><code class="docutils literal notranslate"><span class="pre">GeoFrame.intersection()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.intersection_all"><code class="docutils literal notranslate"><span class="pre">GeoFrame.intersection_all()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.intersects"><code class="docutils literal notranslate"><span class="pre">GeoFrame.intersects()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.is_empty"><code class="docutils literal notranslate"><span class="pre">GeoFrame.is_empty</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.is_ring"><code class="docutils literal notranslate"><span class="pre">GeoFrame.is_ring</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.is_simple"><code class="docutils literal notranslate"><span class="pre">GeoFrame.is_simple</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.is_valid"><code class="docutils literal notranslate"><span class="pre">GeoFrame.is_valid</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.is_valid_reason"><code class="docutils literal notranslate"><span class="pre">GeoFrame.is_valid_reason()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.length"><code class="docutils literal notranslate"><span class="pre">GeoFrame.length</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.make_valid"><code class="docutils literal notranslate"><span class="pre">GeoFrame.make_valid()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.overlaps"><code class="docutils literal notranslate"><span class="pre">GeoFrame.overlaps()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.plot"><code class="docutils literal notranslate"><span class="pre">GeoFrame.plot()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.segmentize"><code class="docutils literal notranslate"><span class="pre">GeoFrame.segmentize()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.simplify"><code class="docutils literal notranslate"><span class="pre">GeoFrame.simplify()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.sindex"><code class="docutils literal notranslate"><span class="pre">GeoFrame.sindex</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.snap"><code class="docutils literal notranslate"><span class="pre">GeoFrame.snap()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.to_geopandas"><code class="docutils literal notranslate"><span class="pre">GeoFrame.to_geopandas()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.to_parquet"><code class="docutils literal notranslate"><span class="pre">GeoFrame.to_parquet()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.total_bounds"><code class="docutils literal notranslate"><span class="pre">GeoFrame.total_bounds</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.touches"><code class="docutils literal notranslate"><span class="pre">GeoFrame.touches()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.type"><code class="docutils literal notranslate"><span class="pre">GeoFrame.type</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.union_all"><code class="docutils literal notranslate"><span class="pre">GeoFrame.union_all()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.within"><code class="docutils literal notranslate"><span class="pre">GeoFrame.within()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#module-sedona.spark.geopandas.geodataframe">sedona.spark.geopandas.geodataframe module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.__init__"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.active_geometry_name"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.active_geometry_name</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.copy"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.copy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.crs"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.crs</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.from_arrow"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.from_arrow()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.from_dict"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.from_dict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.from_features"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.from_features()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.from_file"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.from_file()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.from_postgis"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.from_postgis()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.geometry"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.geometry</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.iterfeatures"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.iterfeatures()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.plot"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.plot()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.rename_geometry"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.rename_geometry()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.set_crs"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.set_crs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.set_geometry"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.set_geometry()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.sjoin"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.sjoin()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.to_arrow"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.to_arrow()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.to_crs"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.to_crs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.to_feather"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.to_feather()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.to_file"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.to_file()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.to_geo_dict"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.to_geo_dict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.to_geopandas"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.to_geopandas()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.to_json"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.to_json()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.to_parquet"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.to_parquet()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.to_spark_pandas"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.to_spark_pandas()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.to_wkb"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.to_wkb()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.to_wkt"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.to_wkt()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.GeoDataFrame.type"><code class="docutils literal notranslate"><span class="pre">GeoDataFrame.type</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geodataframe.MissingGeometryColumnError"><code class="docutils literal notranslate"><span class="pre">MissingGeometryColumnError</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#module-sedona.spark.geopandas.geoseries">sedona.spark.geopandas.geoseries module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries"><code class="docutils literal notranslate"><span class="pre">GeoSeries</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.__init__"><code class="docutils literal notranslate"><span class="pre">GeoSeries.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.area"><code class="docutils literal notranslate"><span class="pre">GeoSeries.area</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.boundary"><code class="docutils literal notranslate"><span class="pre">GeoSeries.boundary</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.bounds"><code class="docutils literal notranslate"><span class="pre">GeoSeries.bounds</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.buffer"><code class="docutils literal notranslate"><span class="pre">GeoSeries.buffer()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.centroid"><code class="docutils literal notranslate"><span class="pre">GeoSeries.centroid</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.clip"><code class="docutils literal notranslate"><span class="pre">GeoSeries.clip()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.concave_hull"><code class="docutils literal notranslate"><span class="pre">GeoSeries.concave_hull()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.contains"><code class="docutils literal notranslate"><span class="pre">GeoSeries.contains()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.contains_properly"><code class="docutils literal notranslate"><span class="pre">GeoSeries.contains_properly()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.convex_hull"><code class="docutils literal notranslate"><span class="pre">GeoSeries.convex_hull</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.copy"><code class="docutils literal notranslate"><span class="pre">GeoSeries.copy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.count_coordinates"><code class="docutils literal notranslate"><span class="pre">GeoSeries.count_coordinates()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.count_geometries"><code class="docutils literal notranslate"><span class="pre">GeoSeries.count_geometries()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.count_interior_rings"><code class="docutils literal notranslate"><span class="pre">GeoSeries.count_interior_rings()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.covered_by"><code class="docutils literal notranslate"><span class="pre">GeoSeries.covered_by()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.covers"><code class="docutils literal notranslate"><span class="pre">GeoSeries.covers()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.crosses"><code class="docutils literal notranslate"><span class="pre">GeoSeries.crosses()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.crs"><code class="docutils literal notranslate"><span class="pre">GeoSeries.crs</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.delaunay_triangles"><code class="docutils literal notranslate"><span class="pre">GeoSeries.delaunay_triangles()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.difference"><code class="docutils literal notranslate"><span class="pre">GeoSeries.difference()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.disjoint"><code class="docutils literal notranslate"><span class="pre">GeoSeries.disjoint()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.distance"><code class="docutils literal notranslate"><span class="pre">GeoSeries.distance()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.dwithin"><code class="docutils literal notranslate"><span class="pre">GeoSeries.dwithin()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.envelope"><code class="docutils literal notranslate"><span class="pre">GeoSeries.envelope</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.estimate_utm_crs"><code class="docutils literal notranslate"><span class="pre">GeoSeries.estimate_utm_crs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.explode"><code class="docutils literal notranslate"><span class="pre">GeoSeries.explode()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.exterior"><code class="docutils literal notranslate"><span class="pre">GeoSeries.exterior</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.extract_unique_points"><code class="docutils literal notranslate"><span class="pre">GeoSeries.extract_unique_points()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.fillna"><code class="docutils literal notranslate"><span class="pre">GeoSeries.fillna()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.force_2d"><code class="docutils literal notranslate"><span class="pre">GeoSeries.force_2d()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.force_3d"><code class="docutils literal notranslate"><span class="pre">GeoSeries.force_3d()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.from_arrow"><code class="docutils literal notranslate"><span class="pre">GeoSeries.from_arrow()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.from_file"><code class="docutils literal notranslate"><span class="pre">GeoSeries.from_file()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.from_shapely"><code class="docutils literal notranslate"><span class="pre">GeoSeries.from_shapely()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.from_wkb"><code class="docutils literal notranslate"><span class="pre">GeoSeries.from_wkb()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.from_wkt"><code class="docutils literal notranslate"><span class="pre">GeoSeries.from_wkt()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.from_xy"><code class="docutils literal notranslate"><span class="pre">GeoSeries.from_xy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.geom_type"><code class="docutils literal notranslate"><span class="pre">GeoSeries.geom_type</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.geometry"><code class="docutils literal notranslate"><span class="pre">GeoSeries.geometry</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.get_geometry"><code class="docutils literal notranslate"><span class="pre">GeoSeries.get_geometry()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.get_precision"><code class="docutils literal notranslate"><span class="pre">GeoSeries.get_precision()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.has_sindex"><code class="docutils literal notranslate"><span class="pre">GeoSeries.has_sindex</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.has_z"><code class="docutils literal notranslate"><span class="pre">GeoSeries.has_z</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.interiors"><code class="docutils literal notranslate"><span class="pre">GeoSeries.interiors</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.intersection"><code class="docutils literal notranslate"><span class="pre">GeoSeries.intersection()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.intersection_all"><code class="docutils literal notranslate"><span class="pre">GeoSeries.intersection_all()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.intersects"><code class="docutils literal notranslate"><span class="pre">GeoSeries.intersects()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.is_ccw"><code class="docutils literal notranslate"><span class="pre">GeoSeries.is_ccw</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.is_closed"><code class="docutils literal notranslate"><span class="pre">GeoSeries.is_closed</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.is_empty"><code class="docutils literal notranslate"><span class="pre">GeoSeries.is_empty</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.is_ring"><code class="docutils literal notranslate"><span class="pre">GeoSeries.is_ring</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.is_simple"><code class="docutils literal notranslate"><span class="pre">GeoSeries.is_simple</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.is_valid"><code class="docutils literal notranslate"><span class="pre">GeoSeries.is_valid</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.is_valid_reason"><code class="docutils literal notranslate"><span class="pre">GeoSeries.is_valid_reason()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.isna"><code class="docutils literal notranslate"><span class="pre">GeoSeries.isna()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.isnull"><code class="docutils literal notranslate"><span class="pre">GeoSeries.isnull()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.length"><code class="docutils literal notranslate"><span class="pre">GeoSeries.length</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.line_merge"><code class="docutils literal notranslate"><span class="pre">GeoSeries.line_merge()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.m"><code class="docutils literal notranslate"><span class="pre">GeoSeries.m</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.make_valid"><code class="docutils literal notranslate"><span class="pre">GeoSeries.make_valid()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.minimum_bounding_circle"><code class="docutils literal notranslate"><span class="pre">GeoSeries.minimum_bounding_circle()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.minimum_bounding_radius"><code class="docutils literal notranslate"><span class="pre">GeoSeries.minimum_bounding_radius()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.minimum_clearance"><code class="docutils literal notranslate"><span class="pre">GeoSeries.minimum_clearance()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.minimum_rotated_rectangle"><code class="docutils literal notranslate"><span class="pre">GeoSeries.minimum_rotated_rectangle()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.normalize"><code class="docutils literal notranslate"><span class="pre">GeoSeries.normalize()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.notna"><code class="docutils literal notranslate"><span class="pre">GeoSeries.notna()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.notnull"><code class="docutils literal notranslate"><span class="pre">GeoSeries.notnull()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.offset_curve"><code class="docutils literal notranslate"><span class="pre">GeoSeries.offset_curve()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.overlaps"><code class="docutils literal notranslate"><span class="pre">GeoSeries.overlaps()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.plot"><code class="docutils literal notranslate"><span class="pre">GeoSeries.plot()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.remove_repeated_points"><code class="docutils literal notranslate"><span class="pre">GeoSeries.remove_repeated_points()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.representative_point"><code class="docutils literal notranslate"><span class="pre">GeoSeries.representative_point()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.reverse"><code class="docutils literal notranslate"><span class="pre">GeoSeries.reverse()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.segmentize"><code class="docutils literal notranslate"><span class="pre">GeoSeries.segmentize()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.set_crs"><code class="docutils literal notranslate"><span class="pre">GeoSeries.set_crs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.set_precision"><code class="docutils literal notranslate"><span class="pre">GeoSeries.set_precision()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.simplify"><code class="docutils literal notranslate"><span class="pre">GeoSeries.simplify()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.sindex"><code class="docutils literal notranslate"><span class="pre">GeoSeries.sindex</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.snap"><code class="docutils literal notranslate"><span class="pre">GeoSeries.snap()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.to_arrow"><code class="docutils literal notranslate"><span class="pre">GeoSeries.to_arrow()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.to_crs"><code class="docutils literal notranslate"><span class="pre">GeoSeries.to_crs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.to_file"><code class="docutils literal notranslate"><span class="pre">GeoSeries.to_file()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.to_geoframe"><code class="docutils literal notranslate"><span class="pre">GeoSeries.to_geoframe()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.to_geopandas"><code class="docutils literal notranslate"><span class="pre">GeoSeries.to_geopandas()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.to_json"><code class="docutils literal notranslate"><span class="pre">GeoSeries.to_json()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.to_parquet"><code class="docutils literal notranslate"><span class="pre">GeoSeries.to_parquet()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.to_spark_pandas"><code class="docutils literal notranslate"><span class="pre">GeoSeries.to_spark_pandas()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.to_wkb"><code class="docutils literal notranslate"><span class="pre">GeoSeries.to_wkb()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.to_wkt"><code class="docutils literal notranslate"><span class="pre">GeoSeries.to_wkt()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.total_bounds"><code class="docutils literal notranslate"><span class="pre">GeoSeries.total_bounds</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.touches"><code class="docutils literal notranslate"><span class="pre">GeoSeries.touches()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.transform"><code class="docutils literal notranslate"><span class="pre">GeoSeries.transform()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.type"><code class="docutils literal notranslate"><span class="pre">GeoSeries.type</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.unary_union"><code class="docutils literal notranslate"><span class="pre">GeoSeries.unary_union</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.union_all"><code class="docutils literal notranslate"><span class="pre">GeoSeries.union_all()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.voronoi_polygons"><code class="docutils literal notranslate"><span class="pre">GeoSeries.voronoi_polygons()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.within"><code class="docutils literal notranslate"><span class="pre">GeoSeries.within()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.x"><code class="docutils literal notranslate"><span class="pre">GeoSeries.x</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.y"><code class="docutils literal notranslate"><span class="pre">GeoSeries.y</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.geoseries.GeoSeries.z"><code class="docutils literal notranslate"><span class="pre">GeoSeries.z</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#module-sedona.spark.geopandas.io">sedona.spark.geopandas.io module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.io.read_file"><code class="docutils literal notranslate"><span class="pre">read_file()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.io.read_parquet"><code class="docutils literal notranslate"><span class="pre">read_parquet()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#module-sedona.spark.geopandas.sindex">sedona.spark.geopandas.sindex module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.sindex.SpatialIndex"><code class="docutils literal notranslate"><span class="pre">SpatialIndex</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.sindex.SpatialIndex.__init__"><code class="docutils literal notranslate"><span class="pre">SpatialIndex.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.sindex.SpatialIndex.intersection"><code class="docutils literal notranslate"><span class="pre">SpatialIndex.intersection()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.sindex.SpatialIndex.is_empty"><code class="docutils literal notranslate"><span class="pre">SpatialIndex.is_empty</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.sindex.SpatialIndex.nearest"><code class="docutils literal notranslate"><span class="pre">SpatialIndex.nearest()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.sindex.SpatialIndex.query"><code class="docutils literal notranslate"><span class="pre">SpatialIndex.query()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.sindex.SpatialIndex.size"><code class="docutils literal notranslate"><span class="pre">SpatialIndex.size</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.spark.geopandas.html#module-sedona.spark.geopandas">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../sedona.stac.html">sedona.stac package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.stac.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.stac.html#module-sedona.stac.client">sedona.stac.client module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.stac.html#module-sedona.stac.collection_client">sedona.stac.collection_client module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.stac.html#module-sedona.stac">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../sedona.stats.html">sedona.stats package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.stats.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.stats.clustering.html">sedona.stats.clustering package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.stats.clustering.html#subpackages">Subpackages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.stats.clustering.html#module-sedona.stats.clustering">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.stats.hotspot_detection.html">sedona.stats.hotspot_detection package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.stats.hotspot_detection.html#subpackages">Subpackages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.stats.hotspot_detection.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.stats.hotspot_detection.html#module-sedona.stats.hotspot_detection.getis_ord">sedona.stats.hotspot_detection.getis_ord module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.stats.hotspot_detection.html#module-sedona.stats.hotspot_detection">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.stats.outlier_detection.html">sedona.stats.outlier_detection package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.stats.outlier_detection.html#subpackages">Subpackages</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.stats.outlier_detection.html#module-sedona.stats.outlier_detection">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.stats.weighting.html">sedona.stats.weighting package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.stats.weighting.html#module-sedona.stats.weighting">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.stats.html#module-sedona.stats">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../sedona.utils.html">sedona.utils package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.utils.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../sedona.utils.structured_adapter.html">sedona.utils.structured_adapter package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../sedona.utils.structured_adapter.html#module-sedona.utils.structured_adapter">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.utils.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.utils.html#module-sedona.utils.adapter">sedona.utils.adapter module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.utils.html#module-sedona.utils.spatial_rdd_parser">sedona.utils.spatial_rdd_parser module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sedona.utils.html#module-sedona.utils">Module contents</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #ff5722" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Apache Sedona Python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">sedona.spark.geopandas.base</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
    <div class="sedona-content-wrapper">
        
           <div itemprop="articleBody">
             
  <h1>Source code for sedona.spark.geopandas.base</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed to the Apache Software Foundation (ASF) under one</span>
<span class="c1"># or more contributor license agreements.  See the NOTICE file</span>
<span class="c1"># distributed with this work for additional information</span>
<span class="c1"># regarding copyright ownership.  The ASF licenses this file</span>
<span class="c1"># to you under the Apache License, Version 2.0 (the</span>
<span class="c1"># &quot;License&quot;); you may not use this file except in compliance</span>
<span class="c1"># with the License.  You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing,</span>
<span class="c1"># software distributed under the License is distributed on an</span>
<span class="c1"># &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span>
<span class="c1"># KIND, either express or implied.  See the License for the</span>
<span class="c1"># specific language governing permissions and limitations</span>
<span class="c1"># under the License.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A base class of Sedona/Spark DataFrame/Column to behave like geopandas GeoDataFrame/GeoSeries.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry.base</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseGeometry</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pyspark.pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ps</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pyspark.pandas._typing</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Axis</span><span class="p">,</span>
    <span class="n">Dtype</span><span class="p">,</span>
    <span class="n">Scalar</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pyspark.sql</span><span class="w"> </span><span class="kn">import</span> <span class="n">Column</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">sedona.spark.geopandas._typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">GeoFrameLike</span>

<span class="n">bool_type</span> <span class="o">=</span> <span class="nb">bool</span>


<div class="viewcode-block" id="GeoFrame">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GeoFrame</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A base class for both GeoDataFrame and GeoSeries.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sindex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;SpatialIndex&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a spatial index for the GeoSeries.</span>

<span class="sd">        Note that the spatial index may not be fully</span>
<span class="sd">        initialized until the first use.</span>

<span class="sd">        Currently, sindex is not retained when calling this method from a GeoDataFrame.</span>
<span class="sd">        You can workaround this by first extracting the active geometry column as a GeoSeries,</span>
<span class="sd">        and calling this method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SpatialIndex</span>
<span class="sd">            The spatial index.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Point, box</span>
<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([Point(x, x) for x in range(5)])</span>
<span class="sd">        &gt;&gt;&gt; s.sindex.query(box(1, 1, 3, 3))</span>
<span class="sd">        [Point(1, 1), Point(2, 2), Point(3, 3)]</span>
<span class="sd">        &gt;&gt;&gt; s.has_sindex</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;sindex&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_sindex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check the existence of the spatial index without generating it.</span>

<span class="sd">        Use the `.sindex` attribute on a GeoDataFrame or GeoSeries</span>
<span class="sd">        to generate a spatial index if it does not yet exist,</span>
<span class="sd">        which may take considerable time based on the underlying index</span>
<span class="sd">        implementation.</span>

<span class="sd">        Note that the underlying spatial index may not be fully</span>
<span class="sd">        initialized until the first use.</span>

<span class="sd">        Currently, sindex is not retained when calling this method from a GeoDataFrame.</span>
<span class="sd">        You can workaround this by first extracting the active geometry column as a GeoSeries,</span>
<span class="sd">        and calling this method.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Point</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([Point(x, x) for x in range(5)])</span>
<span class="sd">        &gt;&gt;&gt; s.has_sindex</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; index = s.sindex</span>
<span class="sd">        &gt;&gt;&gt; s.has_sindex</span>
<span class="sd">        True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            `True` if the spatial index has been generated or</span>
<span class="sd">            `False` if not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;has_sindex&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="GeoFrame.copy">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.copy">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">GeoFrameLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">GeoFrameLike</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;This method is not implemented yet.&quot;</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ps</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Series containing the area of each geometry in the GeoSeries expressed in the units of the CRS.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            A Series containing the area of each geometry.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon</span>
<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>

<span class="sd">        &gt;&gt;&gt; gs = GeoSeries([Polygon([(0, 0), (1, 0), (1, 1), (0, 1)]), Polygon([(0, 0), (2, 0), (2, 2), (0, 2)])])</span>
<span class="sd">        &gt;&gt;&gt; gs.area</span>
<span class="sd">        0    1.0</span>
<span class="sd">        1    4.0</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;area&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">geom_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a series of strings specifying the geometry type of each geometry of each object.</span>

<span class="sd">        Note: Unlike Geopandas, Sedona returns LineString instead of LinearRing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            A Series containing the geometry type of each geometry.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon, Point</span>
<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>

<span class="sd">        &gt;&gt;&gt; gs = GeoSeries([Polygon([(0, 0), (1, 0), (1, 1), (0, 1)]), Point(0, 0)])</span>
<span class="sd">        &gt;&gt;&gt; gs.geom_type</span>
<span class="sd">        0    POLYGON</span>
<span class="sd">        1    POINT</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;geom_type&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;This method is not implemented yet.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Series containing the length of each geometry in the GeoSeries.</span>

<span class="sd">        In the case of a (Multi)Polygon it measures the length of its exterior (i.e. perimeter).</span>

<span class="sd">        For a GeometryCollection it measures sums the values for each of the individual geometries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            A Series containing the length of each geometry.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon</span>
<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>

<span class="sd">        &gt;&gt;&gt; gs = GeoSeries([Point(0, 0), LineString([(0, 0), (1, 1)]), Polygon([(0, 0), (1, 0), (1, 1)]), GeometryCollection([Point(0, 0), LineString([(0, 0), (1, 1)]), Polygon([(0, 0), (1, 0), (1, 1)])])])</span>
<span class="sd">        &gt;&gt;&gt; gs.length</span>
<span class="sd">        0    0.000000</span>
<span class="sd">        1    1.414214</span>
<span class="sd">        2    3.414214</span>
<span class="sd">        3    4.828427</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;length&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a ``Series`` of ``dtype(&#39;bool&#39;)`` with value ``True`` for</span>
<span class="sd">        geometries that are valid.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        An example with one invalid polygon (a bowtie geometry crossing itself)</span>
<span class="sd">        and one missing geometry:</span>

<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (1, 1), (0, 1)]),</span>
<span class="sd">        ...         Polygon([(0,0), (1, 1), (1, 0), (0, 1)]),  # bowtie geometry</span>
<span class="sd">        ...         Polygon([(0, 0), (2, 2), (2, 0)]),</span>
<span class="sd">        ...         None</span>
<span class="sd">        ...     ]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0         POLYGON ((0 0, 1 1, 0 1, 0 0))</span>
<span class="sd">        1    POLYGON ((0 0, 1 1, 1 0, 0 1, 0 0))</span>
<span class="sd">        2         POLYGON ((0 0, 2 2, 2 0, 0 0))</span>
<span class="sd">        3                                   None</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s.is_valid</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        2     True</span>
<span class="sd">        3    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        GeoSeries.is_valid_reason : reason for invalidity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;is_valid&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="GeoFrame.is_valid_reason">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.is_valid_reason">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_valid_reason</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a ``Series`` of strings with the reason for invalidity of</span>
<span class="sd">        each geometry.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        An example with one invalid polygon (a bowtie geometry crossing itself)</span>
<span class="sd">        and one missing geometry:</span>

<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (1, 1), (0, 1)]),</span>
<span class="sd">        ...         Polygon([(0,0), (1, 1), (1, 0), (0, 1)]),  # bowtie geometry</span>
<span class="sd">        ...         Polygon([(0, 0), (2, 2), (2, 0)]),</span>
<span class="sd">        ...         Polygon([(0, 0), (2, 0), (1, 1), (2, 2), (0, 2), (1, 1), (0, 0)]),</span>
<span class="sd">        ...         None</span>
<span class="sd">        ...     ]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0         POLYGON ((0 0, 1 1, 0 1, 0 0))</span>
<span class="sd">        1    POLYGON ((0 0, 1 1, 1 0, 0 1, 0 0))</span>
<span class="sd">        2         POLYGON ((0 0, 2 2, 2 0, 0 0))</span>
<span class="sd">        3                                   None</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s.is_valid_reason()</span>
<span class="sd">        0    Valid Geometry</span>
<span class="sd">        1    Self-intersection at or near point (0.5, 0.5, NaN)</span>
<span class="sd">        2    Valid Geometry</span>
<span class="sd">        3    Ring Self-intersection at or near point (1.0, 1.0)</span>
<span class="sd">        4    None</span>
<span class="sd">        dtype: object</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        GeoSeries.is_valid : detect invalid geometries</span>
<span class="sd">        GeoSeries.make_valid : fix invalid geometries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;is_valid_reason&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a ``Series`` of ``dtype(&#39;bool&#39;)`` with value ``True`` for</span>
<span class="sd">        empty geometries.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        An example of a GeoDataFrame with one empty point, one point and one missing</span>
<span class="sd">        value:</span>

<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Point</span>
<span class="sd">        &gt;&gt;&gt; geoseries = GeoSeries([Point(), Point(2, 1), None], crs=&quot;EPSG:4326&quot;)</span>
<span class="sd">        &gt;&gt;&gt; geoseries</span>
<span class="sd">        0  POINT EMPTY</span>
<span class="sd">        1  POINT (2 1)</span>
<span class="sd">        2         None</span>

<span class="sd">        &gt;&gt;&gt; geoseries.is_empty</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        2    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        GeoSeries.isna : detect missing geometries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;is_empty&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="c1"># def count_coordinates(self):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="c1"># def count_geometries(self):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="c1"># def count_interior_rings(self):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_simple</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a ``Series`` of ``dtype(&#39;bool&#39;)`` with value ``True`` for</span>
<span class="sd">        geometries that do not cross themselves.</span>

<span class="sd">        This is meaningful only for `LineStrings` and `LinearRings`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import LineString</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         LineString([(0, 0), (1, 1), (1, -1), (0, 1)]),</span>
<span class="sd">        ...         LineString([(0, 0), (1, 1), (1, -1)]),</span>
<span class="sd">        ...     ]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    LINESTRING (0 0, 1 1, 1 -1, 0 1)</span>
<span class="sd">        1         LINESTRING (0 0, 1 1, 1 -1)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s.is_simple</span>
<span class="sd">        0    False</span>
<span class="sd">        1     True</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;is_simple&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a ``Series`` of ``dtype(&#39;bool&#39;)`` with value ``True`` for</span>
<span class="sd">        features that are closed.</span>

<span class="sd">        When constructing a LinearRing, the sequence of coordinates may be</span>
<span class="sd">        explicitly closed by passing identical values in the first and last indices.</span>
<span class="sd">        Otherwise, the sequence will be implicitly closed by copying the first tuple</span>
<span class="sd">        to the last index.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import LineString, LinearRing</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         LineString([(0, 0), (1, 1), (1, -1)]),</span>
<span class="sd">        ...         LineString([(0, 0), (1, 1), (1, -1), (0, 0)]),</span>
<span class="sd">        ...         LinearRing([(0, 0), (1, 1), (1, -1)]),</span>
<span class="sd">        ...     ]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0         LINESTRING (0 0, 1 1, 1 -1)</span>
<span class="sd">        1    LINESTRING (0 0, 1 1, 1 -1, 0 0)</span>
<span class="sd">        2    LINEARRING (0 0, 1 1, 1 -1, 0 0)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s.is_ring</span>
<span class="sd">        0    False</span>
<span class="sd">        1     True</span>
<span class="sd">        2     True</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;is_ring&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="c1"># @property</span>
    <span class="c1"># def is_ccw(self):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="c1"># @property</span>
    <span class="c1"># def is_closed(self):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_z</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a ``Series`` of ``dtype(&#39;bool&#39;)`` with value ``True`` for</span>
<span class="sd">        features that have a z-component.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Every operation in GeoPandas is planar, i.e. the potential third</span>
<span class="sd">        dimension is not taken into account.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Point</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Point(0, 1),</span>
<span class="sd">        ...         Point(0, 1, 2),</span>
<span class="sd">        ...     ]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0        POINT (0 1)</span>
<span class="sd">        1    POINT Z (0 1 2)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s.has_z</span>
<span class="sd">        0    False</span>
<span class="sd">        1     True</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;has_z&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="c1"># def get_precision(self):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

<div class="viewcode-block" id="GeoFrame.get_geometry">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.get_geometry">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the n-th geometry from a collection of geometries (0-indexed).</span>

<span class="sd">        If the index is non-negative, it returns the geometry at that index.</span>
<span class="sd">        If the index is negative, it counts backward from the end of the collection (e.g., -1 returns the last geometry).</span>
<span class="sd">        Returns None if the index is out of bounds.</span>

<span class="sd">        Note: Simple geometries act as length-1 collections</span>

<span class="sd">        Note: Using Shapely &lt; 2.0, may lead to different results for empty simple geometries due to how</span>
<span class="sd">        shapely interprets them.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int or array_like</span>
<span class="sd">            Position of a geometry to be retrieved within its collection</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Simple geometries act as collections of length 1. Any out-of-range index value</span>
<span class="sd">        returns None.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Point, MultiPoint, GeometryCollection</span>
<span class="sd">        &gt;&gt;&gt; s = geopandas.GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Point(0, 0),</span>
<span class="sd">        ...         MultiPoint([(0, 0), (1, 1), (0, 1), (1, 0)]),</span>
<span class="sd">        ...         GeometryCollection(</span>
<span class="sd">        ...             [MultiPoint([(0, 0), (1, 1), (0, 1), (1, 0)]), Point(0, 1)]</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...         Polygon(),</span>
<span class="sd">        ...         GeometryCollection(),</span>
<span class="sd">        ...     ]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0                                          POINT (0 0)</span>
<span class="sd">        1              MULTIPOINT ((0 0), (1 1), (0 1), (1 0))</span>
<span class="sd">        2    GEOMETRYCOLLECTION (MULTIPOINT ((0 0), (1 1), ...</span>
<span class="sd">        3                                        POLYGON EMPTY</span>
<span class="sd">        4                             GEOMETRYCOLLECTION EMPTY</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s.get_geometry(0)</span>
<span class="sd">        0                                POINT (0 0)</span>
<span class="sd">        1                                POINT (0 0)</span>
<span class="sd">        2    MULTIPOINT ((0 0), (1 1), (0 1), (1 0))</span>
<span class="sd">        3                              POLYGON EMPTY</span>
<span class="sd">        4                                       None</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s.get_geometry(1)</span>
<span class="sd">        0           None</span>
<span class="sd">        1    POINT (1 1)</span>
<span class="sd">        2    POINT (0 1)</span>
<span class="sd">        3           None</span>
<span class="sd">        4           None</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s.get_geometry(-1)</span>
<span class="sd">        0    POINT (0 0)</span>
<span class="sd">        1    POINT (1 0)</span>
<span class="sd">        2    POINT (0 1)</span>
<span class="sd">        3  POLYGON EMPTY</span>
<span class="sd">        4           None</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;get_geometry&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a ``GeoSeries`` of lower dimensional objects representing</span>
<span class="sd">        each geometry&#39;s set-theoretic `boundary`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon, LineString, Point</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (1, 1), (0, 1)]),</span>
<span class="sd">        ...         LineString([(0, 0), (1, 1), (1, 0)]),</span>
<span class="sd">        ...         Point(0, 0),</span>
<span class="sd">        ...     ]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POLYGON ((0 0, 1 1, 0 1, 0 0))</span>
<span class="sd">        1        LINESTRING (0 0, 1 1, 1 0)</span>
<span class="sd">        2                       POINT (0 0)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s.boundary</span>
<span class="sd">        0    LINESTRING (0 0, 1 1, 0 1, 0 0)</span>
<span class="sd">        1          MULTIPOINT ((0 0), (1 0))</span>
<span class="sd">        2           GEOMETRYCOLLECTION EMPTY</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        GeoSeries.exterior : outer boundary (without interior rings)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;boundary&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a ``GeoSeries`` of points representing the centroid of each</span>
<span class="sd">        geometry.</span>

<span class="sd">        Note that centroid does not have to be on or within original geometry.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon, LineString, Point</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (1, 1), (0, 1)]),</span>
<span class="sd">        ...         LineString([(0, 0), (1, 1), (1, 0)]),</span>
<span class="sd">        ...         Point(0, 0),</span>
<span class="sd">        ...     ]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POLYGON ((0 0, 1 1, 0 1, 0 0))</span>
<span class="sd">        1        LINESTRING (0 0, 1 1, 1 0)</span>
<span class="sd">        2                       POINT (0 0)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s.centroid</span>
<span class="sd">        0    POINT (0.33333 0.66667)</span>
<span class="sd">        1        POINT (0.70711 0.5)</span>
<span class="sd">        2                POINT (0 0)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        GeoSeries.representative_point : point guaranteed to be within each geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;centroid&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="c1"># def concave_hull(self, ratio=0.0, allow_holes=False):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="c1"># @property</span>
    <span class="c1"># def convex_hull(self):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="c1"># def delaunay_triangles(self, tolerance=0.0, only_edges=False):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="c1"># def voronoi_polygons(self, tolerance=0.0, extend_to=None, only_edges=False):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">envelope</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a ``GeoSeries`` of geometries representing the envelope of</span>
<span class="sd">        each geometry.</span>

<span class="sd">        The envelope of a geometry is the bounding rectangle. That is, the</span>
<span class="sd">        point or smallest rectangular polygon (with sides parallel to the</span>
<span class="sd">        coordinate axes) that contains the geometry.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon, LineString, Point, MultiPoint</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (1, 1), (0, 1)]),</span>
<span class="sd">        ...         LineString([(0, 0), (1, 1), (1, 0)]),</span>
<span class="sd">        ...         MultiPoint([(0, 0), (1, 1)]),</span>
<span class="sd">        ...         Point(0, 0),</span>
<span class="sd">        ...     ]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POLYGON ((0 0, 1 1, 0 1, 0 0))</span>
<span class="sd">        1        LINESTRING (0 0, 1 1, 1 0)</span>
<span class="sd">        2         MULTIPOINT ((0 0), (1 1))</span>
<span class="sd">        3                       POINT (0 0)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s.envelope</span>
<span class="sd">        0    POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0))</span>
<span class="sd">        1    POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0))</span>
<span class="sd">        2    POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0))</span>
<span class="sd">        3                            POINT (0 0)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        GeoSeries.convex_hull : convex hull geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;envelope&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="c1"># def minimum_rotated_rectangle(self):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="c1"># @property</span>
    <span class="c1"># def exterior(self):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="c1"># def extract_unique_points(self):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="c1"># def offset_curve(self, distance, quad_segs=8, join_style=&quot;round&quot;, mitre_limit=5.0):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="c1"># @property</span>
    <span class="c1"># def interiors(self):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="c1"># def remove_repeated_points(self, tolerance=0.0):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="c1"># def set_precision(self, grid_size, mode=&quot;valid_output&quot;):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="c1"># def representative_point(self):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="c1"># def minimum_bounding_circle(self):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="c1"># def minimum_bounding_radius(self):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="c1"># def minimum_clearance(self):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="c1"># def normalize(self):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

<div class="viewcode-block" id="GeoFrame.make_valid">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.make_valid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linework&quot;</span><span class="p">,</span> <span class="n">keep_collapsed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Repairs invalid geometries.</span>

<span class="sd">        Returns a ``GeoSeries`` with valid geometries.</span>

<span class="sd">        If the input geometry is already valid, then it will be preserved.</span>
<span class="sd">        In many cases, in order to create a valid geometry, the input</span>
<span class="sd">        geometry must be split into multiple parts or multiple geometries.</span>
<span class="sd">        If the geometry must be split into multiple parts of the same type</span>
<span class="sd">        to be made valid, then a multi-part geometry will be returned</span>
<span class="sd">        (e.g. a MultiPolygon).</span>
<span class="sd">        If the geometry must be split into multiple parts of different types</span>
<span class="sd">        to be made valid, then a GeometryCollection will be returned.</span>

<span class="sd">        In Sedona, only the &#39;structure&#39; method is available:</span>

<span class="sd">        * the &#39;structure&#39; algorithm tries to reason from the structure of the</span>
<span class="sd">          input to find the &#39;correct&#39; repair: exterior rings bound area,</span>
<span class="sd">          interior holes exclude area. It first makes all rings valid, then</span>
<span class="sd">          shells are merged and holes are subtracted from the shells to</span>
<span class="sd">          generate valid result. It assumes that holes and shells are correctly</span>
<span class="sd">          categorized in the input geometry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : {&#39;linework&#39;, &#39;structure&#39;}, default &#39;linework&#39;</span>
<span class="sd">            Algorithm to use when repairing geometry. Sedona Geopandas only supports the &#39;structure&#39; method.</span>
<span class="sd">            The default method is &quot;linework&quot; to match compatibility with Geopandas, but it must be explicitly set to</span>
<span class="sd">            &#39;structure&#39; to use the Sedona implementation.</span>

<span class="sd">        keep_collapsed : bool, default True</span>
<span class="sd">            For the &#39;structure&#39; method, True will keep components that have</span>
<span class="sd">            collapsed into a lower dimensionality. For example, a ring</span>
<span class="sd">            collapsing to a line, or a line collapsing to a point.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import MultiPolygon, Polygon, LineString, Point</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (0, 2), (1, 1), (2, 2), (2, 0), (1, 1), (0, 0)]),</span>
<span class="sd">        ...         Polygon([(0, 2), (0, 1), (2, 0), (0, 0), (0, 2)]),</span>
<span class="sd">        ...         LineString([(0, 0), (1, 1), (1, 0)]),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POLYGON ((0 0, 0 2, 1 1, 2 2, 2 0, 1 1, 0 0))</span>
<span class="sd">        1              POLYGON ((0 2, 0 1, 2 0, 0 0, 0 2))</span>
<span class="sd">        2                       LINESTRING (0 0, 1 1, 1 0)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s.make_valid()</span>
<span class="sd">        0    MULTIPOLYGON (((1 1, 0 0, 0 2, 1 1)), ((2 0, 1...</span>
<span class="sd">        1                       POLYGON ((0 1, 2 0, 0 0, 0 1))</span>
<span class="sd">        2                           LINESTRING (0 0, 1 1, 1 0)</span>
<span class="sd">        dtype: geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span>
            <span class="s2">&quot;make_valid&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">keep_collapsed</span><span class="o">=</span><span class="n">keep_collapsed</span>
        <span class="p">)</span></div>


    <span class="c1"># def reverse(self):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

<div class="viewcode-block" id="GeoFrame.segmentize">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.segmentize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">segmentize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_segment_length</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a ``GeoSeries`` with vertices added to line segments based on</span>
<span class="sd">        maximum segment length.</span>

<span class="sd">        Additional vertices will be added to every line segment in an input geometry so</span>
<span class="sd">        that segments are no longer than the provided maximum segment length. New</span>
<span class="sd">        vertices will evenly subdivide each segment. Only linear components of input</span>
<span class="sd">        geometries are densified; other geometries are returned unmodified.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_segment_length : float | array-like</span>
<span class="sd">            Additional vertices will be added so that all line segments are no longer</span>
<span class="sd">            than this value. Must be greater than 0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon, LineString</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         LineString([(0, 0), (0, 10)]),</span>
<span class="sd">        ...         Polygon([(0, 0), (10, 0), (10, 10), (0, 10), (0, 0)]),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0                     LINESTRING (0 0, 0 10)</span>
<span class="sd">        1    POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s.segmentize(max_segment_length=5)</span>
<span class="sd">        0                          LINESTRING (0 0, 0 5, 0 10)</span>
<span class="sd">        1    POLYGON ((0 0, 5 0, 10 0, 10 5, 10 10, 5 10, 0...</span>
<span class="sd">        dtype: geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;segmentize&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">max_segment_length</span><span class="p">)</span></div>


    <span class="c1"># def transform(self, transformation, include_z=False):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="c1"># def force_2d(self):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="c1"># def force_3d(self, z=0):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="c1"># def line_merge(self, directed=False):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

    <span class="c1"># @property</span>
    <span class="c1"># def unary_union(self):</span>
    <span class="c1">#     raise NotImplementedError(&quot;This method is not implemented yet.&quot;)</span>

<div class="viewcode-block" id="GeoFrame.union_all">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.union_all">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">union_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;unary&quot;</span><span class="p">,</span> <span class="n">grid_size</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BaseGeometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a geometry containing the union of all geometries in the</span>
<span class="sd">        ``GeoSeries``.</span>

<span class="sd">        Sedona does not support the method or grid_size argument, so the user does not need to manually</span>
<span class="sd">        decide the algorithm being used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str (default ``&quot;unary&quot;``)</span>
<span class="sd">            Not supported in Sedona.</span>

<span class="sd">        grid_size : float, default None</span>
<span class="sd">            Not supported in Sedona.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import box</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries([box(0, 0, 1, 1), box(0, 0, 2, 2)])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POLYGON ((1 0, 1 1, 0 1, 0 0, 1 0))</span>
<span class="sd">        1    POLYGON ((2 0, 2 2, 0 2, 0 0, 2 0))</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s.union_all()</span>
<span class="sd">        &lt;POLYGON ((0 1, 0 2, 2 2, 2 0, 1 0, 0 0, 0 1))&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;union_all&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">)</span></div>


<div class="viewcode-block" id="GeoFrame.crosses">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.crosses">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">crosses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ps</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a ``Series`` of ``dtype(&#39;bool&#39;)`` with value ``True`` for</span>
<span class="sd">        each aligned geometry that cross `other`.</span>

<span class="sd">        An object is said to cross `other` if its `interior` intersects the</span>
<span class="sd">        `interior` of the other but does not contain it, and the dimension of</span>
<span class="sd">        the intersection is less than the dimension of the one or the other.</span>

<span class="sd">        Note: Unlike Geopandas, Sedona&#39;s implementation always return NULL when GeometryCollection is involved.</span>

<span class="sd">        The operation works on a 1-to-1 row-wise manner.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : GeoSeries or geometric object</span>
<span class="sd">            The GeoSeries (elementwise) or geometric object to test if is</span>
<span class="sd">            crossed.</span>
<span class="sd">        align : bool | None (default None)</span>
<span class="sd">            If True, automatically aligns GeoSeries based on their indices. None defaults to True.</span>
<span class="sd">            If False, the order of elements is preserved.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series (bool)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon, LineString, Point</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (2, 2), (0, 2)]),</span>
<span class="sd">        ...         LineString([(0, 0), (2, 2)]),</span>
<span class="sd">        ...         LineString([(2, 0), (0, 2)]),</span>
<span class="sd">        ...         Point(0, 1),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         LineString([(1, 0), (1, 3)]),</span>
<span class="sd">        ...         LineString([(2, 0), (0, 2)]),</span>
<span class="sd">        ...         Point(1, 1),</span>
<span class="sd">        ...         Point(0, 1),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ...     index=range(1, 5),</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POLYGON ((0 0, 2 2, 0 2, 0 0))</span>
<span class="sd">        1             LINESTRING (0 0, 2 2)</span>
<span class="sd">        2             LINESTRING (2 0, 0 2)</span>
<span class="sd">        3                       POINT (0 1)</span>
<span class="sd">        dtype: geometry</span>
<span class="sd">        &gt;&gt;&gt; s2</span>
<span class="sd">        1    LINESTRING (1 0, 1 3)</span>
<span class="sd">        2    LINESTRING (2 0, 0 2)</span>
<span class="sd">        3              POINT (1 1)</span>
<span class="sd">        4              POINT (0 1)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        We can check if each geometry of GeoSeries crosses a single</span>
<span class="sd">        geometry:</span>

<span class="sd">        &gt;&gt;&gt; line = LineString([(-1, 1), (3, 1)])</span>
<span class="sd">        &gt;&gt;&gt; s.crosses(line)</span>
<span class="sd">        0     True</span>
<span class="sd">        1     True</span>
<span class="sd">        2     True</span>
<span class="sd">        3    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        We can also check two GeoSeries against each other, row by row.</span>
<span class="sd">        The GeoSeries above have different indices. We can either align both GeoSeries</span>
<span class="sd">        based on index values and compare elements with the same index using</span>
<span class="sd">        ``align=True`` or ignore index and compare elements based on their matching</span>
<span class="sd">        order using ``align=False``:</span>

<span class="sd">        &gt;&gt;&gt; s.crosses(s2, align=True)</span>
<span class="sd">        0    False</span>
<span class="sd">        1     True</span>
<span class="sd">        2    False</span>
<span class="sd">        3    False</span>
<span class="sd">        4    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        &gt;&gt;&gt; s.crosses(s2, align=False)</span>
<span class="sd">        0     True</span>
<span class="sd">        1     True</span>
<span class="sd">        2    False</span>
<span class="sd">        3    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        Notice that a line does not cross a point that it contains.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method works in a row-wise manner. It does not check if an element</span>
<span class="sd">        of one GeoSeries ``crosses`` *any* element of the other one.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        GeoSeries.disjoint</span>
<span class="sd">        GeoSeries.intersects</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;crosses&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span></div>


<div class="viewcode-block" id="GeoFrame.intersects">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.intersects">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">intersects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a ``Series`` of ``dtype(&#39;bool&#39;)`` with value ``True`` for</span>
<span class="sd">        each aligned geometry that intersects `other`.</span>

<span class="sd">        An object is said to intersect `other` if its `boundary` and `interior`</span>
<span class="sd">        intersects in any way with those of the other.</span>

<span class="sd">        The operation works on a 1-to-1 row-wise manner.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : GeoSeries or geometric object</span>
<span class="sd">            The GeoSeries (elementwise) or geometric object to test if is</span>
<span class="sd">            intersected.</span>
<span class="sd">        align : bool | None (default None)</span>
<span class="sd">            If True, automatically aligns GeoSeries based on their indices. None defaults to True.</span>
<span class="sd">            If False, the order of elements is preserved.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series (bool)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon, LineString, Point</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (2, 2), (0, 2)]),</span>
<span class="sd">        ...         LineString([(0, 0), (2, 2)]),</span>
<span class="sd">        ...         LineString([(2, 0), (0, 2)]),</span>
<span class="sd">        ...         Point(0, 1),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         LineString([(1, 0), (1, 3)]),</span>
<span class="sd">        ...         LineString([(2, 0), (0, 2)]),</span>
<span class="sd">        ...         Point(1, 1),</span>
<span class="sd">        ...         Point(0, 1),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ...     index=range(1, 5),</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POLYGON ((0 0, 2 2, 0 2, 0 0))</span>
<span class="sd">        1             LINESTRING (0 0, 2 2)</span>
<span class="sd">        2             LINESTRING (2 0, 0 2)</span>
<span class="sd">        3                       POINT (0 1)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s2</span>
<span class="sd">        1    LINESTRING (1 0, 1 3)</span>
<span class="sd">        2    LINESTRING (2 0, 0 2)</span>
<span class="sd">        3              POINT (1 1)</span>
<span class="sd">        4              POINT (0 1)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        We can check if each geometry of GeoSeries crosses a single</span>
<span class="sd">        geometry:</span>

<span class="sd">        &gt;&gt;&gt; line = LineString([(-1, 1), (3, 1)])</span>
<span class="sd">        &gt;&gt;&gt; s.intersects(line)</span>
<span class="sd">        0    True</span>
<span class="sd">        1    True</span>
<span class="sd">        2    True</span>
<span class="sd">        3    True</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        We can also check two GeoSeries against each other, row by row.</span>
<span class="sd">        The GeoSeries above have different indices. We can either align both GeoSeries</span>
<span class="sd">        based on index values and compare elements with the same index using</span>
<span class="sd">        ``align=True`` or ignore index and compare elements based on their matching</span>
<span class="sd">        order using ``align=False``:</span>

<span class="sd">        &gt;&gt;&gt; s.intersects(s2, align=True)</span>
<span class="sd">        0    False</span>
<span class="sd">        1     True</span>
<span class="sd">        2     True</span>
<span class="sd">        3    False</span>
<span class="sd">        4    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        &gt;&gt;&gt; s.intersects(s2, align=False)</span>
<span class="sd">        0    True</span>
<span class="sd">        1    True</span>
<span class="sd">        2    True</span>
<span class="sd">        3    True</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method works in a row-wise manner. It does not check if an element</span>
<span class="sd">        of one GeoSeries ``crosses`` *any* element of the other one.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        GeoSeries.disjoint</span>
<span class="sd">        GeoSeries.crosses</span>
<span class="sd">        GeoSeries.touches</span>
<span class="sd">        GeoSeries.intersection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;intersects&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span></div>


<div class="viewcode-block" id="GeoFrame.overlaps">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.overlaps">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True for all aligned geometries that overlap other, else False.</span>

<span class="sd">        In the original Geopandas, Geometries overlap if they have more than one but not all</span>
<span class="sd">        points in common, have the same dimension, and the intersection of the</span>
<span class="sd">        interiors of the geometries has the same dimension as the geometries</span>
<span class="sd">        themselves.</span>

<span class="sd">        However, in Sedona, we return True in the case where the geometries points match.</span>

<span class="sd">        Note: Sedona&#39;s behavior may also differ from Geopandas for GeometryCollections.</span>

<span class="sd">        The operation works on a 1-to-1 row-wise manner.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : GeoSeries or geometric object</span>
<span class="sd">            The GeoSeries (elementwise) or geometric object to test if</span>
<span class="sd">            overlaps.</span>
<span class="sd">        align : bool | None (default None)</span>
<span class="sd">            If True, automatically aligns GeoSeries based on their indices. None defaults to True.</span>
<span class="sd">            If False, the order of elements is preserved.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series (bool)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon, LineString, MultiPoint, Point</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (2, 2), (0, 2)]),</span>
<span class="sd">        ...         Polygon([(0, 0), (2, 2), (0, 2)]),</span>
<span class="sd">        ...         LineString([(0, 0), (2, 2)]),</span>
<span class="sd">        ...         MultiPoint([(0, 0), (0, 1)]),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (2, 0), (0, 2)]),</span>
<span class="sd">        ...         LineString([(0, 1), (1, 1)]),</span>
<span class="sd">        ...         LineString([(1, 1), (3, 3)]),</span>
<span class="sd">        ...         Point(0, 1),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ... )</span>

<span class="sd">        We can check if each geometry of GeoSeries overlaps a single</span>
<span class="sd">        geometry:</span>

<span class="sd">        &gt;&gt;&gt; polygon = Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])</span>
<span class="sd">        &gt;&gt;&gt; s.overlaps(polygon)</span>
<span class="sd">        0     True</span>
<span class="sd">        1     True</span>
<span class="sd">        2    False</span>
<span class="sd">        3    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        We can also check two GeoSeries against each other, row by row.</span>
<span class="sd">        The GeoSeries above have different indices. We align both GeoSeries</span>
<span class="sd">        based on index values and compare elements with the same index.</span>

<span class="sd">        &gt;&gt;&gt; s.overlaps(s2)</span>
<span class="sd">        0    False</span>
<span class="sd">        1     True</span>
<span class="sd">        2    False</span>
<span class="sd">        3    False</span>
<span class="sd">        4    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        &gt;&gt;&gt; s.overlaps(s2, align=False)</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        2     True</span>
<span class="sd">        3    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method works in a row-wise manner. It does not check if an element</span>
<span class="sd">        of one GeoSeries ``overlaps`` *any* element of the other one.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        GeoSeries.crosses</span>
<span class="sd">        GeoSeries.intersects</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;overlaps&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span></div>


<div class="viewcode-block" id="GeoFrame.touches">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.touches">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">touches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a ``Series`` of ``dtype(&#39;bool&#39;)`` with value ``True`` for</span>
<span class="sd">        each aligned geometry that touches `other`.</span>

<span class="sd">        An object is said to touch `other` if it has at least one point in</span>
<span class="sd">        common with `other` and its interior does not intersect with any part</span>
<span class="sd">        of the other. Overlapping features therefore do not touch.</span>

<span class="sd">        Note: Sedona&#39;s behavior may also differ from Geopandas for GeometryCollections.</span>

<span class="sd">        The operation works on a 1-to-1 row-wise manner.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : GeoSeries or geometric object</span>
<span class="sd">            The GeoSeries (elementwise) or geometric object to test if is</span>
<span class="sd">            touched.</span>
<span class="sd">        align : bool | None (default None)</span>
<span class="sd">            If True, automatically aligns GeoSeries based on their indices. None defaults to True.</span>
<span class="sd">            If False, the order of elements is preserved.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series (bool)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon, LineString, MultiPoint, Point</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (2, 2), (0, 2)]),</span>
<span class="sd">        ...         Polygon([(0, 0), (2, 2), (0, 2)]),</span>
<span class="sd">        ...         LineString([(0, 0), (2, 2)]),</span>
<span class="sd">        ...         MultiPoint([(0, 0), (0, 1)]),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (-2, 0), (0, -2)]),</span>
<span class="sd">        ...         LineString([(0, 1), (1, 1)]),</span>
<span class="sd">        ...         LineString([(1, 1), (3, 0)]),</span>
<span class="sd">        ...         Point(0, 1),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ...     index=range(1, 5),</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POLYGON ((0 0, 2 2, 0 2, 0 0))</span>
<span class="sd">        1    POLYGON ((0 0, 2 2, 0 2, 0 0))</span>
<span class="sd">        2             LINESTRING (0 0, 2 2)</span>
<span class="sd">        3         MULTIPOINT ((0 0), (0 1))</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s2</span>
<span class="sd">        1    POLYGON ((0 0, -2 0, 0 -2, 0 0))</span>
<span class="sd">        2               LINESTRING (0 1, 1 1)</span>
<span class="sd">        3               LINESTRING (1 1, 3 0)</span>
<span class="sd">        4                         POINT (0 1)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        We can check if each geometry of GeoSeries touches a single</span>
<span class="sd">        geometry:</span>

<span class="sd">        &gt;&gt;&gt; line = LineString([(0, 0), (-1, -2)])</span>
<span class="sd">        &gt;&gt;&gt; s.touches(line)</span>
<span class="sd">        0    True</span>
<span class="sd">        1    True</span>
<span class="sd">        2    True</span>
<span class="sd">        3    True</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        We can also check two GeoSeries against each other, row by row.</span>
<span class="sd">        The GeoSeries above have different indices. We can either align both GeoSeries</span>
<span class="sd">        based on index values and compare elements with the same index using</span>
<span class="sd">        ``align=True`` or ignore index and compare elements based on their matching</span>
<span class="sd">        order using ``align=False``:</span>

<span class="sd">        &gt;&gt;&gt; s.touches(s2, align=True)</span>
<span class="sd">        0    False</span>
<span class="sd">        1     True</span>
<span class="sd">        2     True</span>
<span class="sd">        3    False</span>
<span class="sd">        4    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        &gt;&gt;&gt; s.touches(s2, align=False)</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        2     True</span>
<span class="sd">        3    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method works in a row-wise manner. It does not check if an element</span>
<span class="sd">        of one GeoSeries ``touches`` *any* element of the other one.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        GeoSeries.overlaps</span>
<span class="sd">        GeoSeries.intersects</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;touches&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span></div>


<div class="viewcode-block" id="GeoFrame.within">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.within">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">within</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a ``Series`` of ``dtype(&#39;bool&#39;)`` with value ``True`` for</span>
<span class="sd">        each aligned geometry that is within `other`.</span>

<span class="sd">        An object is said to be within `other` if at least one of its points is located</span>
<span class="sd">        in the `interior` and no points are located in the `exterior` of the other.</span>
<span class="sd">        If either object is empty, this operation returns ``False``.</span>

<span class="sd">        This is the inverse of `contains` in the sense that the</span>
<span class="sd">        expression ``a.within(b) == b.contains(a)`` always evaluates to</span>
<span class="sd">        ``True``.</span>

<span class="sd">        Note: Sedona&#39;s behavior may also differ from Geopandas for GeometryCollections and for geometries that are equal.</span>

<span class="sd">        The operation works on a 1-to-1 row-wise manner.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : GeoSeries or geometric object</span>
<span class="sd">            The GeoSeries (elementwise) or geometric object to test if each</span>
<span class="sd">            geometry is within.</span>
<span class="sd">        align : bool | None (default None)</span>
<span class="sd">            If True, automatically aligns GeoSeries based on their indices. None defaults to True.</span>
<span class="sd">            If False, the order of elements is preserved.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series (bool)</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon, LineString, Point</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (2, 2), (0, 2)]),</span>
<span class="sd">        ...         Polygon([(0, 0), (1, 2), (0, 2)]),</span>
<span class="sd">        ...         LineString([(0, 0), (0, 2)]),</span>
<span class="sd">        ...         Point(0, 1),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (1, 1), (0, 1)]),</span>
<span class="sd">        ...         LineString([(0, 0), (0, 2)]),</span>
<span class="sd">        ...         LineString([(0, 0), (0, 1)]),</span>
<span class="sd">        ...         Point(0, 1),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ...     index=range(1, 5),</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POLYGON ((0 0, 2 2, 0 2, 0 0))</span>
<span class="sd">        1    POLYGON ((0 0, 1 2, 0 2, 0 0))</span>
<span class="sd">        2             LINESTRING (0 0, 0 2)</span>
<span class="sd">        3                       POINT (0 1)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s2</span>
<span class="sd">        1    POLYGON ((0 0, 1 1, 0 1, 0 0))</span>
<span class="sd">        2             LINESTRING (0 0, 0 2)</span>
<span class="sd">        3             LINESTRING (0 0, 0 1)]</span>
<span class="sd">        4                       POINT (0 1)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        We can check if each geometry of GeoSeries is within a single</span>
<span class="sd">        geometry:</span>

<span class="sd">        &gt;&gt;&gt; polygon = Polygon([(0, 0), (2, 2), (0, 2)])</span>
<span class="sd">        &gt;&gt;&gt; s.within(polygon)</span>
<span class="sd">        0     True</span>
<span class="sd">        1     True</span>
<span class="sd">        2    False</span>
<span class="sd">        3    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        We can also check two GeoSeries against each other, row by row.</span>
<span class="sd">        The GeoSeries above have different indices. We can either align both GeoSeries</span>
<span class="sd">        based on index values and compare elements with the same index using</span>
<span class="sd">        ``align=True`` or ignore index and compare elements based on their matching</span>
<span class="sd">        order using ``align=False``:</span>

<span class="sd">        &gt;&gt;&gt; s2.within(s)</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        2     True</span>
<span class="sd">        3    False</span>
<span class="sd">        4    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        &gt;&gt;&gt; s2.within(s, align=False)</span>
<span class="sd">        1     True</span>
<span class="sd">        2    False</span>
<span class="sd">        3     True</span>
<span class="sd">        4     True</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method works in a row-wise manner. It does not check if an element</span>
<span class="sd">        of one GeoSeries is ``within`` any element of the other one.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        GeoSeries.contains</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;within&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span></div>


<div class="viewcode-block" id="GeoFrame.covers">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.covers">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">covers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a ``Series`` of ``dtype(&#39;bool&#39;)`` with value ``True`` for</span>
<span class="sd">        each aligned geometry that is entirely covering `other`.</span>

<span class="sd">        An object A is said to cover another object B if no points of B lie</span>
<span class="sd">        in the exterior of A.</span>
<span class="sd">        If either object is empty, this operation returns ``False``.</span>

<span class="sd">        Note: Sedona&#39;s implementation instead returns False for identical geometries.</span>
<span class="sd">        Sedona&#39;s behavior may also differ from Geopandas for GeometryCollections.</span>

<span class="sd">        The operation works on a 1-to-1 row-wise manner.</span>

<span class="sd">        See</span>
<span class="sd">        https://lin-ear-th-inking.blogspot.com/2007/06/subtleties-of-ogc-covers-spatial.html</span>
<span class="sd">        for reference.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geoseries or geometric object</span>
<span class="sd">            The Geoseries (elementwise) or geometric object to check is being covered.</span>
<span class="sd">        align : bool | None (default None)</span>
<span class="sd">            If True, automatically aligns GeoSeries based on their indices. None defaults to True.</span>
<span class="sd">            If False, the order of elements is preserved.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series (bool)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon, LineString, Point</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (2, 0), (2, 2), (0, 2)]),</span>
<span class="sd">        ...         Polygon([(0, 0), (2, 2), (0, 2)]),</span>
<span class="sd">        ...         LineString([(0, 0), (2, 2)]),</span>
<span class="sd">        ...         Point(0, 0),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0.5, 0.5), (1.5, 0.5), (1.5, 1.5), (0.5, 1.5)]),</span>
<span class="sd">        ...         Polygon([(0, 0), (2, 0), (2, 2), (0, 2)]),</span>
<span class="sd">        ...         LineString([(1, 1), (1.5, 1.5)]),</span>
<span class="sd">        ...         Point(0, 0),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ...     index=range(1, 5),</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POLYGON ((0 0, 2 0, 2 2, 0 2, 0 0))</span>
<span class="sd">        1         POLYGON ((0 0, 2 2, 0 2, 0 0))</span>
<span class="sd">        2                  LINESTRING (0 0, 2 2)</span>
<span class="sd">        3                            POINT (0 0)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s2</span>
<span class="sd">        1    POLYGON ((0.5 0.5, 1.5 0.5, 1.5 1.5, 0.5 1.5, ...</span>
<span class="sd">        2                  POLYGON ((0 0, 2 0, 2 2, 0 2, 0 0))</span>
<span class="sd">        3                            LINESTRING (1 1, 1.5 1.5)</span>
<span class="sd">        4                                          POINT (0 0)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        We can check if each geometry of GeoSeries covers a single</span>
<span class="sd">        geometry:</span>

<span class="sd">        &gt;&gt;&gt; poly = Polygon([(0, 0), (2, 0), (2, 2), (0, 2)])</span>
<span class="sd">        &gt;&gt;&gt; s.covers(poly)</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        2    False</span>
<span class="sd">        3    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        We can also check two GeoSeries against each other, row by row.</span>
<span class="sd">        The GeoSeries above have different indices. We can either align both GeoSeries</span>
<span class="sd">        based on index values and compare elements with the same index using</span>
<span class="sd">        ``align=True`` or ignore index and compare elements based on their matching</span>
<span class="sd">        order using ``align=False``:</span>

<span class="sd">        &gt;&gt;&gt; s.covers(s2, align=True)</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        2    False</span>
<span class="sd">        3    False</span>
<span class="sd">        4    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        &gt;&gt;&gt; s.covers(s2, align=False)</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        2     True</span>
<span class="sd">        3     True</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method works in a row-wise manner. It does not check if an element</span>
<span class="sd">        of one GeoSeries ``covers`` any element of the other one.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        GeoSeries.covered_by</span>
<span class="sd">        GeoSeries.overlaps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;covers&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span></div>


<div class="viewcode-block" id="GeoFrame.covered_by">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.covered_by">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">covered_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a ``Series`` of ``dtype(&#39;bool&#39;)`` with value ``True`` for</span>
<span class="sd">        each aligned geometry that is entirely covered by `other`.</span>

<span class="sd">        An object A is said to cover another object B if no points of B lie</span>
<span class="sd">        in the exterior of A.</span>

<span class="sd">        Note: Sedona&#39;s implementation instead returns False for identical geometries.</span>
<span class="sd">        Sedona&#39;s behavior may differ from Geopandas for GeometryCollections.</span>

<span class="sd">        The operation works on a 1-to-1 row-wise manner.</span>

<span class="sd">        See</span>
<span class="sd">        https://lin-ear-th-inking.blogspot.com/2007/06/subtleties-of-ogc-covers-spatial.html</span>
<span class="sd">        for reference.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geoseries or geometric object</span>
<span class="sd">            The Geoseries (elementwise) or geometric object to check is being covered.</span>
<span class="sd">        align : bool | None (default None)</span>
<span class="sd">            If True, automatically aligns GeoSeries based on their indices. None defaults to True.</span>
<span class="sd">            If False, the order of elements is preserved.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series (bool)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon, LineString, Point</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0.5, 0.5), (1.5, 0.5), (1.5, 1.5), (0.5, 1.5)]),</span>
<span class="sd">        ...         Polygon([(0, 0), (2, 0), (2, 2), (0, 2)]),</span>
<span class="sd">        ...         LineString([(1, 1), (1.5, 1.5)]),</span>
<span class="sd">        ...         Point(0, 0),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (2, 0), (2, 2), (0, 2)]),</span>
<span class="sd">        ...         Polygon([(0, 0), (2, 2), (0, 2)]),</span>
<span class="sd">        ...         LineString([(0, 0), (2, 2)]),</span>
<span class="sd">        ...         Point(0, 0),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ...     index=range(1, 5),</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POLYGON ((0.5 0.5, 1.5 0.5, 1.5 1.5, 0.5 1.5, ...</span>
<span class="sd">        1                  POLYGON ((0 0, 2 0, 2 2, 0 2, 0 0))</span>
<span class="sd">        2                            LINESTRING (1 1, 1.5 1.5)</span>
<span class="sd">        3                                          POINT (0 0)</span>
<span class="sd">        dtype: geometry</span>
<span class="sd">        &gt;&gt;&gt;</span>

<span class="sd">        &gt;&gt;&gt; s2</span>
<span class="sd">        1    POLYGON ((0 0, 2 0, 2 2, 0 2, 0 0))</span>
<span class="sd">        2         POLYGON ((0 0, 2 2, 0 2, 0 0))</span>
<span class="sd">        3                  LINESTRING (0 0, 2 2)</span>
<span class="sd">        4                            POINT (0 0)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        We can check if each geometry of GeoSeries is covered by a single</span>
<span class="sd">        geometry:</span>

<span class="sd">        &gt;&gt;&gt; poly = Polygon([(0, 0), (2, 0), (2, 2), (0, 2)])</span>
<span class="sd">        &gt;&gt;&gt; s.covered_by(poly)</span>
<span class="sd">        0    True</span>
<span class="sd">        1    True</span>
<span class="sd">        2    True</span>
<span class="sd">        3    True</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        We can also check two GeoSeries against each other, row by row.</span>
<span class="sd">        The GeoSeries above have different indices. We can either align both GeoSeries</span>
<span class="sd">        based on index values and compare elements with the same index using</span>
<span class="sd">        ``align=True`` or ignore index and compare elements based on their matching</span>
<span class="sd">        order using ``align=False``:</span>

<span class="sd">        &gt;&gt;&gt; s.covered_by(s2, align=True)</span>
<span class="sd">        0    False</span>
<span class="sd">        1     True</span>
<span class="sd">        2     True</span>
<span class="sd">        3     True</span>
<span class="sd">        4    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        &gt;&gt;&gt; s.covered_by(s2, align=False)</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        2     True</span>
<span class="sd">        3     True</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method works in a row-wise manner. It does not check if an element</span>
<span class="sd">        of one GeoSeries is ``covered_by`` any element of the other one.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        GeoSeries.covers</span>
<span class="sd">        GeoSeries.overlaps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;covered_by&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span></div>


<div class="viewcode-block" id="GeoFrame.distance">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.distance">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a ``Series`` containing the distance to aligned `other`.</span>

<span class="sd">        The operation works on a 1-to-1 row-wise manner:</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geoseries or geometric object</span>
<span class="sd">            The Geoseries (elementwise) or geometric object to find the</span>
<span class="sd">            distance to.</span>
<span class="sd">        align : bool | None (default None)</span>
<span class="sd">            If True, automatically aligns GeoSeries based on their indices. None defaults to True.</span>
<span class="sd">            If False, the order of elements is preserved.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series (float)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon, LineString, Point</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (1, 0), (1, 1)]),</span>
<span class="sd">        ...         Polygon([(0, 0), (-1, 0), (-1, 1)]),</span>
<span class="sd">        ...         LineString([(1, 1), (0, 0)]),</span>
<span class="sd">        ...         Point(0, 0),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0.5, 0.5), (1.5, 0.5), (1.5, 1.5), (0.5, 1.5)]),</span>
<span class="sd">        ...         Point(3, 1),</span>
<span class="sd">        ...         LineString([(1, 0), (2, 0)]),</span>
<span class="sd">        ...         Point(0, 1),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ...     index=range(1, 5),</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0      POLYGON ((0 0, 1 0, 1 1, 0 0))</span>
<span class="sd">        1    POLYGON ((0 0, -1 0, -1 1, 0 0))</span>
<span class="sd">        2               LINESTRING (1 1, 0 0)</span>
<span class="sd">        3                         POINT (0 0)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s2</span>
<span class="sd">        1    POLYGON ((0.5 0.5, 1.5 0.5, 1.5 1.5, 0.5 1.5, ...</span>
<span class="sd">        2                                          POINT (3 1)</span>
<span class="sd">        3                                LINESTRING (1 0, 2 0)</span>
<span class="sd">        4                                          POINT (0 1)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        We can check the distance of each geometry of GeoSeries to a single</span>
<span class="sd">        geometry:</span>

<span class="sd">        &gt;&gt;&gt; point = Point(-1, 0)</span>
<span class="sd">        &gt;&gt;&gt; s.distance(point)</span>
<span class="sd">        0    1.0</span>
<span class="sd">        1    0.0</span>
<span class="sd">        2    1.0</span>
<span class="sd">        3    1.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        We can also check two GeoSeries against each other, row by row.</span>
<span class="sd">        The GeoSeries above have different indices. We can either align both GeoSeries</span>
<span class="sd">        based on index values and use elements with the same index using</span>
<span class="sd">        ``align=True`` or ignore index and use elements based on their matching</span>
<span class="sd">        order using ``align=False``:</span>

<span class="sd">        &gt;&gt;&gt; s.distance(s2, align=True)</span>
<span class="sd">        0         NaN</span>
<span class="sd">        1    0.707107</span>
<span class="sd">        2    2.000000</span>
<span class="sd">        3    1.000000</span>
<span class="sd">        4         NaN</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; s.distance(s2, align=False)</span>
<span class="sd">        0    0.000000</span>
<span class="sd">        1    3.162278</span>
<span class="sd">        2    0.707107</span>
<span class="sd">        3    1.000000</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span></div>


<div class="viewcode-block" id="GeoFrame.intersection">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.intersection">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a ``GeoSeries`` of the intersection of points in each</span>
<span class="sd">        aligned geometry with `other`.</span>

<span class="sd">        The operation works on a 1-to-1 row-wise manner.</span>

<span class="sd">        Note: Unlike most functions, intersection may return the unordered with respect to the index.</span>
<span class="sd">        If this is important to you, you may call ``sort_index()`` on the result.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geoseries or geometric object</span>
<span class="sd">            The Geoseries (elementwise) or geometric object to find the</span>
<span class="sd">            intersection with.</span>
<span class="sd">        align : bool | None (default None)</span>
<span class="sd">            If True, automatically aligns GeoSeries based on their indices. None defaults to True.</span>
<span class="sd">            If False, the order of elements is preserved.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon, LineString, Point</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (2, 2), (0, 2)]),</span>
<span class="sd">        ...         Polygon([(0, 0), (2, 2), (0, 2)]),</span>
<span class="sd">        ...         LineString([(0, 0), (2, 2)]),</span>
<span class="sd">        ...         LineString([(2, 0), (0, 2)]),</span>
<span class="sd">        ...         Point(0, 1),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (1, 1), (0, 1)]),</span>
<span class="sd">        ...         LineString([(1, 0), (1, 3)]),</span>
<span class="sd">        ...         LineString([(2, 0), (0, 2)]),</span>
<span class="sd">        ...         Point(1, 1),</span>
<span class="sd">        ...         Point(0, 1),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ...     index=range(1, 6),</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POLYGON ((0 0, 2 2, 0 2, 0 0))</span>
<span class="sd">        1    POLYGON ((0 0, 2 2, 0 2, 0 0))</span>
<span class="sd">        2             LINESTRING (0 0, 2 2)</span>
<span class="sd">        3             LINESTRING (2 0, 0 2)</span>
<span class="sd">        4                       POINT (0 1)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s2</span>
<span class="sd">        1    POLYGON ((0 0, 1 1, 0 1, 0 0))</span>
<span class="sd">        2             LINESTRING (1 0, 1 3)</span>
<span class="sd">        3             LINESTRING (2 0, 0 2)</span>
<span class="sd">        4                       POINT (1 1)</span>
<span class="sd">        5                       POINT (0 1)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        We can also do intersection of each geometry and a single</span>
<span class="sd">        shapely geometry:</span>

<span class="sd">        &gt;&gt;&gt; s.intersection(Polygon([(0, 0), (1, 1), (0, 1)]))</span>
<span class="sd">        0    POLYGON ((0 0, 0 1, 1 1, 0 0))</span>
<span class="sd">        1    POLYGON ((0 0, 0 1, 1 1, 0 0))</span>
<span class="sd">        2             LINESTRING (0 0, 1 1)</span>
<span class="sd">        3                       POINT (1 1)</span>
<span class="sd">        4                       POINT (0 1)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        We can also check two GeoSeries against each other, row by row.</span>
<span class="sd">        The GeoSeries above have different indices. We can either align both GeoSeries</span>
<span class="sd">        based on index values and compare elements with the same index using</span>
<span class="sd">        ``align=True`` or ignore index and compare elements based on their matching</span>
<span class="sd">        order using ``align=False``:</span>

<span class="sd">        &gt;&gt;&gt; s.intersection(s2, align=True)</span>
<span class="sd">        0                              None</span>
<span class="sd">        1    POLYGON ((0 0, 0 1, 1 1, 0 0))</span>
<span class="sd">        2                       POINT (1 1)</span>
<span class="sd">        3             LINESTRING (2 0, 0 2)</span>
<span class="sd">        4                       POINT EMPTY</span>
<span class="sd">        5                              None</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s.intersection(s2, align=False)</span>
<span class="sd">        0    POLYGON ((0 0, 0 1, 1 1, 0 0))</span>
<span class="sd">        1             LINESTRING (1 1, 1 2)</span>
<span class="sd">        2                       POINT (1 1)</span>
<span class="sd">        3                       POINT (1 1)</span>
<span class="sd">        4                       POINT (0 1)</span>
<span class="sd">        dtype: geometry</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        GeoSeries.difference</span>
<span class="sd">        GeoSeries.symmetric_difference</span>
<span class="sd">        GeoSeries.union</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;intersection&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span></div>


<div class="viewcode-block" id="GeoFrame.snap">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.snap">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">snap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Snap the vertices and segments of the geometry to vertices of the reference.</span>

<span class="sd">        Vertices and segments of the input geometry are snapped to vertices of the</span>
<span class="sd">        reference geometry, returning a new geometry; the input geometries are not</span>
<span class="sd">        modified. The result geometry is the input geometry with the vertices and</span>
<span class="sd">        segments snapped. If no snapping occurs then the input geometry is returned</span>
<span class="sd">        unchanged. The tolerance is used to control where snapping is performed.</span>

<span class="sd">        Where possible, this operation tries to avoid creating invalid geometries;</span>
<span class="sd">        however, it does not guarantee that output geometries will be valid. It is</span>
<span class="sd">        the responsibility of the caller to check for and handle invalid geometries.</span>

<span class="sd">        Because too much snapping can result in invalid geometries being created,</span>
<span class="sd">        heuristics are used to determine the number and location of snapped</span>
<span class="sd">        vertices that are likely safe to snap. These heuristics may omit</span>
<span class="sd">        some potential snaps that are otherwise within the tolerance.</span>

<span class="sd">        Note: Sedona&#39;s result may differ slightly from geopandas&#39;s snap() result</span>
<span class="sd">        because of small differences between the underlying engines being used.</span>

<span class="sd">        The operation works in a 1-to-1 row-wise manner:</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : GeoSeries or geometric object</span>
<span class="sd">            The Geoseries (elementwise) or geometric object to snap to.</span>
<span class="sd">        tolerance : float or array like</span>
<span class="sd">            Maximum distance between vertices that shall be snapped</span>
<span class="sd">        align : bool | None (default None)</span>
<span class="sd">            If True, automatically aligns GeoSeries based on their indices. None defaults to True.</span>
<span class="sd">            If False, the order of elements is preserved.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from shapely import Polygon, LineString, Point</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Point(0.5, 2.5),</span>
<span class="sd">        ...         LineString([(0.1, 0.1), (0.49, 0.51), (1.01, 0.89)]),</span>
<span class="sd">        ...         Polygon([(0, 0), (0, 10), (10, 10), (10, 0), (0, 0)]),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0                               POINT (0.5 2.5)</span>
<span class="sd">        1    LINESTRING (0.1 0.1, 0.49 0.51, 1.01 0.89)</span>
<span class="sd">        2       POLYGON ((0 0, 0 10, 10 10, 10 0, 0 0))</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Point(0, 2),</span>
<span class="sd">        ...         LineString([(0, 0), (0.5, 0.5), (1.0, 1.0)]),</span>
<span class="sd">        ...         Point(8, 10),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ...     index=range(1, 4),</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s2</span>
<span class="sd">        1                       POINT (0 2)</span>
<span class="sd">        2    LINESTRING (0 0, 0.5 0.5, 1 1)</span>
<span class="sd">        3                      POINT (8 10)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        We can snap each geometry to a single shapely geometry:</span>

<span class="sd">        &gt;&gt;&gt; s.snap(Point(0, 2), tolerance=1)</span>
<span class="sd">        0                                     POINT (0 2)</span>
<span class="sd">        1      LINESTRING (0.1 0.1, 0.49 0.51, 1.01 0.89)</span>
<span class="sd">        2    POLYGON ((0 0, 0 2, 0 10, 10 10, 10 0, 0 0))</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        We can also snap two GeoSeries to each other, row by row.</span>
<span class="sd">        The GeoSeries above have different indices. We can either align both GeoSeries</span>
<span class="sd">        based on index values and snap elements with the same index using</span>
<span class="sd">        ``align=True`` or ignore index and snap elements based on their matching</span>
<span class="sd">        order using ``align=False``:</span>

<span class="sd">        &gt;&gt;&gt; s.snap(s2, tolerance=1, align=True)</span>
<span class="sd">        0                                                 None</span>
<span class="sd">        1           LINESTRING (0.1 0.1, 0.49 0.51, 1.01 0.89)</span>
<span class="sd">        2    POLYGON ((0.5 0.5, 1 1, 0 10, 10 10, 10 0, 0.5...</span>
<span class="sd">        3                                                 None</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s.snap(s2, tolerance=1, align=False)</span>
<span class="sd">        0                                      POINT (0 2)</span>
<span class="sd">        1                   LINESTRING (0 0, 0.5 0.5, 1 1)</span>
<span class="sd">        2    POLYGON ((0 0, 0 10, 8 10, 10 10, 10 0, 0 0))</span>
<span class="sd">        dtype: geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;snap&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ps</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a ``DataFrame`` with columns ``minx``, ``miny``, ``maxx``,</span>
<span class="sd">        ``maxy`` values containing the bounds for each geometry.</span>

<span class="sd">        See ``GeoSeries.total_bounds`` for the limits of the entire series.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Point, Polygon, LineString</span>
<span class="sd">        &gt;&gt;&gt; d = {&#39;geometry&#39;: [Point(2, 1), Polygon([(0, 0), (1, 1), (1, 0)]),</span>
<span class="sd">        ... LineString([(0, 1), (1, 2)])]}</span>
<span class="sd">        &gt;&gt;&gt; gdf = geopandas.GeoDataFrame(d, crs=&quot;EPSG:4326&quot;)</span>
<span class="sd">        &gt;&gt;&gt; gdf.bounds</span>
<span class="sd">           minx  miny  maxx  maxy</span>
<span class="sd">        0   2.0   1.0   2.0   1.0</span>
<span class="sd">        1   0.0   0.0   1.0   1.0</span>
<span class="sd">        2   0.0   1.0   1.0   2.0</span>

<span class="sd">        You can assign the bounds to the ``GeoDataFrame`` as:</span>

<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; gdf = pd.concat([gdf, gdf.bounds], axis=1)</span>
<span class="sd">        &gt;&gt;&gt; gdf</span>
<span class="sd">                                geometry  minx  miny  maxx  maxy</span>
<span class="sd">        0                     POINT (2 1)   2.0   1.0   2.0   1.0</span>
<span class="sd">        1  POLYGON ((0 0, 1 1, 1 0, 0 0))   0.0   0.0   1.0   1.0</span>
<span class="sd">        2           LINESTRING (0 1, 1 2)   0.0   1.0   1.0   2.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;bounds&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">total_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a tuple containing ``minx``, ``miny``, ``maxx``, ``maxy``</span>
<span class="sd">        values for the bounds of the series as a whole.</span>

<span class="sd">        See ``GeoSeries.bounds`` for the bounds of the geometries contained in</span>
<span class="sd">        the series.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Point, Polygon, LineString</span>
<span class="sd">        &gt;&gt;&gt; d = {&#39;geometry&#39;: [Point(3, -1), Polygon([(0, 0), (1, 1), (1, 0)]),</span>
<span class="sd">        ... LineString([(0, 1), (1, 2)])]}</span>
<span class="sd">        &gt;&gt;&gt; gdf = geopandas.GeoDataFrame(d, crs=&quot;EPSG:4326&quot;)</span>
<span class="sd">        &gt;&gt;&gt; gdf.total_bounds</span>
<span class="sd">        array([ 0., -1.,  3.,  2.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;total_bounds&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="GeoFrame.dwithin">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.dwithin">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dwithin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a ``Series`` of ``dtype(&#39;bool&#39;)`` with value ``True`` for</span>
<span class="sd">        each aligned geometry that is within a set distance from ``other``.</span>

<span class="sd">        The operation works on a 1-to-1 row-wise manner:</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : GeoSeries or geometric object</span>
<span class="sd">            The GeoSeries (elementwise) or geometric object to test for</span>
<span class="sd">            equality.</span>
<span class="sd">        distance : float, np.array, pd.Series</span>
<span class="sd">            Distance(s) to test if each geometry is within. A scalar distance will be</span>
<span class="sd">            applied to all geometries. An array or Series will be applied elementwise.</span>
<span class="sd">            If np.array or pd.Series are used then it must have same length as the</span>
<span class="sd">            GeoSeries.</span>
<span class="sd">        align : bool | None (default None)</span>
<span class="sd">            If True, automatically aligns GeoSeries based on their indices.</span>
<span class="sd">            If False, the order of elements is preserved. None defaults to True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series (bool)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon, LineString, Point</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (1, 1), (0, 1)]),</span>
<span class="sd">        ...         LineString([(0, 0), (0, 2)]),</span>
<span class="sd">        ...         LineString([(0, 0), (0, 1)]),</span>
<span class="sd">        ...         Point(0, 1),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ...     index=range(0, 4),</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(1, 0), (4, 2), (2, 2)]),</span>
<span class="sd">        ...         Polygon([(2, 0), (3, 2), (2, 2)]),</span>
<span class="sd">        ...         LineString([(2, 0), (2, 2)]),</span>
<span class="sd">        ...         Point(1, 1),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ...     index=range(1, 5),</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POLYGON ((0 0, 1 1, 0 1, 0 0))</span>
<span class="sd">        1             LINESTRING (0 0, 0 2)</span>
<span class="sd">        2             LINESTRING (0 0, 0 1)</span>
<span class="sd">        3                       POINT (0 1)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s2</span>
<span class="sd">        1    POLYGON ((1 0, 4 2, 2 2, 1 0))</span>
<span class="sd">        2    POLYGON ((2 0, 3 2, 2 2, 2 0))</span>
<span class="sd">        3             LINESTRING (2 0, 2 2)</span>
<span class="sd">        4                       POINT (1 1)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        We can check if each geometry of GeoSeries contains a single</span>
<span class="sd">        geometry:</span>

<span class="sd">        &gt;&gt;&gt; point = Point(0, 1)</span>
<span class="sd">        &gt;&gt;&gt; s2.dwithin(point, 1.8)</span>
<span class="sd">        1     True</span>
<span class="sd">        2    False</span>
<span class="sd">        3    False</span>
<span class="sd">        4     True</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        We can also check two GeoSeries against each other, row by row.</span>
<span class="sd">        The GeoSeries above have different indices. We can either align both GeoSeries</span>
<span class="sd">        based on index values and compare elements with the same index using</span>
<span class="sd">        ``align=True`` or ignore index and compare elements based on their matching</span>
<span class="sd">        order using ``align=False``:</span>

<span class="sd">        &gt;&gt;&gt; s.dwithin(s2, distance=1, align=True)</span>
<span class="sd">        0    False</span>
<span class="sd">        1     True</span>
<span class="sd">        2    False</span>
<span class="sd">        3    False</span>
<span class="sd">        4    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        &gt;&gt;&gt; s.dwithin(s2, distance=1, align=False)</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        2    False</span>
<span class="sd">        3     True</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method works in a row-wise manner. It does not check if an element</span>
<span class="sd">        of one GeoSeries is within the set distance of *any* element of the other one.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        GeoSeries.within</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;dwithin&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span></div>


<div class="viewcode-block" id="GeoFrame.difference">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.difference">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a ``GeoSeries`` of the points in each aligned geometry that</span>
<span class="sd">        are not in `other`.</span>

<span class="sd">        The operation works on a 1-to-1 row-wise manner:</span>

<span class="sd">        Unlike Geopandas, Sedona does not support this operation for GeometryCollections.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geoseries or geometric object</span>
<span class="sd">            The Geoseries (elementwise) or geometric object to find the</span>
<span class="sd">            difference to.</span>
<span class="sd">        align : bool | None (default None)</span>
<span class="sd">            If True, automatically aligns GeoSeries based on their indices. None defaults to True.</span>
<span class="sd">            If False, the order of elements is preserved.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon, LineString, Point</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (2, 2), (0, 2)]),</span>
<span class="sd">        ...         Polygon([(0, 0), (2, 2), (0, 2)]),</span>
<span class="sd">        ...         LineString([(0, 0), (2, 2)]),</span>
<span class="sd">        ...         LineString([(2, 0), (0, 2)]),</span>
<span class="sd">        ...         Point(0, 1),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (1, 1), (0, 1)]),</span>
<span class="sd">        ...         LineString([(1, 0), (1, 3)]),</span>
<span class="sd">        ...         LineString([(2, 0), (0, 2)]),</span>
<span class="sd">        ...         Point(1, 1),</span>
<span class="sd">        ...         Point(0, 1),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ...     index=range(1, 6),</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POLYGON ((0 0, 2 2, 0 2, 0 0))</span>
<span class="sd">        1    POLYGON ((0 0, 2 2, 0 2, 0 0))</span>
<span class="sd">        2             LINESTRING (0 0, 2 2)</span>
<span class="sd">        3             LINESTRING (2 0, 0 2)</span>
<span class="sd">        4                       POINT (0 1)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s2</span>
<span class="sd">        1    POLYGON ((0 0, 1 1, 0 1, 0 0))</span>
<span class="sd">        2             LINESTRING (1 0, 1 3)</span>
<span class="sd">        3             LINESTRING (2 0, 0 2)</span>
<span class="sd">        4                       POINT (1 1)</span>
<span class="sd">        5                       POINT (0 1)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        We can check if each geometry of GeoSeries contains a single</span>
<span class="sd">        geometry:</span>

<span class="sd">        &gt;&gt;&gt; point = Point(0, 1)</span>
<span class="sd">        &gt;&gt;&gt; s2.difference(point)</span>
<span class="sd">        1    POLYGON ((0 0, 1 1, 0 1, 0 0))</span>
<span class="sd">        2             LINESTRING (1 0, 1 3)</span>
<span class="sd">        3             LINESTRING (2 0, 0 2)</span>
<span class="sd">        4                       POINT (1 1)</span>
<span class="sd">        5           GEOMETRYCOLLECTION EMPTY</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        We can also check two GeoSeries against each other, row by row.</span>
<span class="sd">        The GeoSeries above have different indices. We can either align both GeoSeries</span>
<span class="sd">        based on index values and compare elements with the same index using</span>
<span class="sd">        ``align=True`` or ignore index and compare elements based on their matching</span>
<span class="sd">        order using ``align=False``:</span>

<span class="sd">        &gt;&gt;&gt; s.difference(s2, align=True)</span>
<span class="sd">        0    POLYGON ((0 0, 2 2, 0 2, 0 0))</span>
<span class="sd">        1    POLYGON ((0 0, 2 2, 0 2, 0 0))</span>
<span class="sd">        2             LINESTRING (0 0, 2 2)</span>
<span class="sd">        3             LINESTRING (2 0, 0 2)</span>
<span class="sd">        4                       POINT (0 1)</span>
<span class="sd">        5                       POINT (0 1)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s.difference(s2, align=False)</span>
<span class="sd">        0    POLYGON ((0 0, 2 2, 0 2, 0 0))</span>
<span class="sd">        1    POLYGON ((0 0, 2 2, 0 2, 0 0))</span>
<span class="sd">        2           GEOMETRYCOLLECTION EMPTY</span>
<span class="sd">        3             LINESTRING (2 0, 0 2)</span>
<span class="sd">        4           GEOMETRYCOLLECTION EMPTY</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method works in a row-wise manner. It does not check if an element</span>
<span class="sd">        of one GeoSeries is different from *any* element of the other one.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        GeoSeries.intersection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;difference&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span></div>


<div class="viewcode-block" id="GeoFrame.intersection_all">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.intersection_all">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">intersection_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;This method is not implemented yet.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="GeoFrame.contains">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.contains">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a ``Series`` of ``dtype(&#39;bool&#39;)`` with value ``True`` for</span>
<span class="sd">        each aligned geometry that contains `other`.</span>

<span class="sd">        An object is said to contain `other` if at least one point of `other` lies in</span>
<span class="sd">        the interior and no points of `other` lie in the exterior of the object.</span>
<span class="sd">        (Therefore, any given polygon does not contain its own boundary - there is not</span>
<span class="sd">        any point that lies in the interior.)</span>
<span class="sd">        If either object is empty, this operation returns ``False``.</span>

<span class="sd">        This is the inverse of `within` in the sense that the expression</span>
<span class="sd">        ``a.contains(b) == b.within(a)`` always evaluates to ``True``.</span>

<span class="sd">        Note: Sedona&#39;s implementation instead returns False for identical geometries.</span>

<span class="sd">        The operation works on a 1-to-1 row-wise manner.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : GeoSeries or geometric object</span>
<span class="sd">            The GeoSeries (elementwise) or geometric object to test if it</span>
<span class="sd">            is contained.</span>
<span class="sd">        align : bool | None (default None)</span>
<span class="sd">            If True, automatically aligns GeoSeries based on their indices. None defaults to True.</span>
<span class="sd">            If False, the order of elements is preserved.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series (bool)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon, LineString, Point</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (1, 1), (0, 1)]),</span>
<span class="sd">        ...         LineString([(0, 0), (0, 2)]),</span>
<span class="sd">        ...         LineString([(0, 0), (0, 1)]),</span>
<span class="sd">        ...         Point(0, 1),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ...     index=range(0, 4),</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s2 = GeoSeries(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         Polygon([(0, 0), (2, 2), (0, 2)]),</span>
<span class="sd">        ...         Polygon([(0, 0), (1, 2), (0, 2)]),</span>
<span class="sd">        ...         LineString([(0, 0), (0, 2)]),</span>
<span class="sd">        ...         Point(0, 1),</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ...     index=range(1, 5),</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POLYGON ((0 0, 1 1, 0 1, 0 0))</span>
<span class="sd">        1             LINESTRING (0 0, 0 2)</span>
<span class="sd">        2             LINESTRING (0 0, 0 1)</span>
<span class="sd">        3                       POINT (0 1)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s2</span>
<span class="sd">        1    POLYGON ((0 0, 2 2, 0 2, 0 0))</span>
<span class="sd">        2    POLYGON ((0 0, 1 2, 0 2, 0 0))</span>
<span class="sd">        3             LINESTRING (0 0, 0 2)</span>
<span class="sd">        4                       POINT (0 1)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        We can check if each geometry of GeoSeries contains a single</span>
<span class="sd">        geometry:</span>

<span class="sd">        &gt;&gt;&gt; point = Point(0, 1)</span>
<span class="sd">        &gt;&gt;&gt; s.contains(point)</span>
<span class="sd">        0    False</span>
<span class="sd">        1     True</span>
<span class="sd">        2    False</span>
<span class="sd">        3     True</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        We can also check two GeoSeries against each other, row by row.</span>
<span class="sd">        The GeoSeries above have different indices. We can either align both GeoSeries</span>
<span class="sd">        based on index values and compare elements with the same index using</span>
<span class="sd">        ``align=True`` or ignore index and compare elements based on their matching</span>
<span class="sd">        order using ``align=False``:</span>

<span class="sd">        &gt;&gt;&gt; s2.contains(s, align=True)</span>
<span class="sd">        0    False</span>
<span class="sd">        1    False</span>
<span class="sd">        2    False</span>
<span class="sd">        3     True</span>
<span class="sd">        4    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        &gt;&gt;&gt; s2.contains(s, align=False)</span>
<span class="sd">        1     True</span>
<span class="sd">        2    False</span>
<span class="sd">        3     True</span>
<span class="sd">        4     True</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method works in a row-wise manner. It does not check if an element</span>
<span class="sd">        of one GeoSeries ``contains`` any element of the other one.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        GeoSeries.contains_properly</span>
<span class="sd">        GeoSeries.within</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span><span class="s2">&quot;contains&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span></div>


<div class="viewcode-block" id="GeoFrame.contains_properly">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.contains_properly">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">contains_properly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;This method is not implemented yet.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="GeoFrame.to_parquet">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.to_parquet">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_parquet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;This method is not implemented yet.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="GeoFrame.buffer">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.buffer">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">buffer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">distance</span><span class="p">,</span>
        <span class="n">resolution</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
        <span class="n">cap_style</span><span class="o">=</span><span class="s2">&quot;round&quot;</span><span class="p">,</span>
        <span class="n">join_style</span><span class="o">=</span><span class="s2">&quot;round&quot;</span><span class="p">,</span>
        <span class="n">mitre_limit</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span>
        <span class="n">single_sided</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a GeoSeries with all geometries buffered by the specified distance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        distance : float</span>
<span class="sd">            The distance to buffer by. Negative distances will create inward buffers.</span>
<span class="sd">        resolution : int, default 16</span>
<span class="sd">            The resolution of the buffer around each vertex. Specifies the number of</span>
<span class="sd">            linear segments in a quarter circle in the approximation of circular arcs.</span>
<span class="sd">        cap_style : str, default &quot;round&quot;</span>
<span class="sd">            The style of the buffer cap. One of &#39;round&#39;, &#39;flat&#39;, &#39;square&#39;.</span>
<span class="sd">        join_style : str, default &quot;round&quot;</span>
<span class="sd">            The style of the buffer join. One of &#39;round&#39;, &#39;mitre&#39;, &#39;bevel&#39;.</span>
<span class="sd">        mitre_limit : float, default 5.0</span>
<span class="sd">            The mitre limit ratio for joins when join_style=&#39;mitre&#39;.</span>
<span class="sd">        single_sided : bool, default False</span>
<span class="sd">            Whether to create a single-sided buffer. In Sedona, True will default to left-sided buffer.</span>
<span class="sd">            However, &#39;right&#39; may be specified to use a right-sided buffer.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GeoSeries</span>
<span class="sd">            A new GeoSeries with buffered geometries.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Point</span>
<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoDataFrame</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; data = {</span>
<span class="sd">        ...     &#39;geometry&#39;: [Point(0, 0), Point(1, 1)],</span>
<span class="sd">        ...     &#39;value&#39;: [1, 2]</span>
<span class="sd">        ... }</span>
<span class="sd">        &gt;&gt;&gt; gdf = GeoDataFrame(data)</span>
<span class="sd">        &gt;&gt;&gt; buffered = gdf.buffer(0.5)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span>
            <span class="s2">&quot;buffer&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">distance</span><span class="p">,</span>
            <span class="n">resolution</span><span class="p">,</span>
            <span class="n">cap_style</span><span class="p">,</span>
            <span class="n">join_style</span><span class="p">,</span>
            <span class="n">mitre_limit</span><span class="p">,</span>
            <span class="n">single_sided</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="GeoFrame.simplify">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.simplify">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">preserve_topology</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a ``GeoSeries`` containing a simplified representation of</span>
<span class="sd">        each geometry.</span>

<span class="sd">        The algorithm (Douglas-Peucker) recursively splits the original line</span>
<span class="sd">        into smaller parts and connects these parts&#39; endpoints</span>
<span class="sd">        by a straight line. Then, it removes all points whose distance</span>
<span class="sd">        to the straight line is smaller than `tolerance`. It does not</span>
<span class="sd">        move any points and it always preserves endpoints of</span>
<span class="sd">        the original line or polygon.</span>
<span class="sd">        See https://shapely.readthedocs.io/en/latest/manual.html#object.simplify</span>
<span class="sd">        for details</span>

<span class="sd">        Simplifies individual geometries independently, without considering</span>
<span class="sd">        the topology of a potential polygonal coverage. If you would like to treat</span>
<span class="sd">        the ``GeoSeries`` as a coverage and simplify its edges, while preserving the</span>
<span class="sd">        coverage topology, see :meth:`simplify_coverage`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tolerance : float</span>
<span class="sd">            All parts of a simplified geometry will be no more than</span>
<span class="sd">            `tolerance` distance from the original. It has the same units</span>
<span class="sd">            as the coordinate reference system of the GeoSeries.</span>
<span class="sd">            For example, using `tolerance=100` in a projected CRS with meters</span>
<span class="sd">            as units means a distance of 100 meters in reality.</span>
<span class="sd">        preserve_topology: bool (default True)</span>
<span class="sd">            False uses a quicker algorithm, but may produce self-intersecting</span>
<span class="sd">            or otherwise invalid geometries.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Invalid geometric objects may result from simplification that does not</span>
<span class="sd">        preserve topology and simplification may be sensitive to the order of</span>
<span class="sd">        coordinates: two geometries differing only in order of coordinates may be</span>
<span class="sd">        simplified differently.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        simplify_coverage : simplify geometries using coverage simplification</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from sedona.spark.geopandas import GeoSeries</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Point, LineString</span>
<span class="sd">        &gt;&gt;&gt; s = GeoSeries(</span>
<span class="sd">        ...     [Point(0, 0).buffer(1), LineString([(0, 0), (1, 10), (0, 20)])]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    POLYGON ((1 0, 0.99518 -0.09802, 0.98079 -0.19...</span>
<span class="sd">        1                         LINESTRING (0 0, 1 10, 0 20)</span>
<span class="sd">        dtype: geometry</span>

<span class="sd">        &gt;&gt;&gt; s.simplify(1)</span>
<span class="sd">        0    POLYGON ((0 1, 0 -1, -1 0, 0 1))</span>
<span class="sd">        1              LINESTRING (0 0, 0 20)</span>
<span class="sd">        dtype: geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_delegate_to_geometry_column</span><span class="p">(</span>
            <span class="s2">&quot;simplify&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">preserve_topology</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="GeoFrame.to_geopandas">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.to_geopandas">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_geopandas</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">]:</span> <span class="o">...</span></div>


<div class="viewcode-block" id="GeoFrame.plot">
<a class="viewcode-back" href="../../../../sedona.spark.geopandas.html#sedona.spark.geopandas.base.GeoFrame.plot">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="o">...</span></div>
</div>



<span class="k">def</span><span class="w"> </span><span class="nf">_delegate_to_geometry_column</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">geom_column</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">geometry</span>
    <span class="n">inplace</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;inplace&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">args</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">geom_column</span><span class="p">,</span> <span class="n">op</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">geom_column</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
        <span class="c1"># If it was a function instead of a property, call it</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="c1"># This assumes this is a GeoSeries</span>
        <span class="n">this</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">geom_column</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">data</span>
</pre></div>

           </div>
          </div>
    </div>

          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Apache Software Foundation.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>